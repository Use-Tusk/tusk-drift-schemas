// This file is @generated by prost-build.
/// Recursive JSON schema message
/// Describes the structure and metadata of JSON data
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonSchema {
    /// The type of this schema node
    #[prost(enumeration = "JsonSchemaType", tag = "1")]
    pub r#type: i32,
    /// For OBJECT types: map of property names to their schemas
    #[prost(map = "string, message", tag = "2")]
    pub properties: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        JsonSchema,
    >,
    /// For ORDERED_LIST/UNORDERED_LIST types: schema of list items
    #[prost(message, optional, boxed, tag = "3")]
    pub items: ::core::option::Option<::prost::alloc::boxed::Box<JsonSchema>>,
    /// Optional encoding information (e.g., BASE64)
    #[prost(enumeration = "EncodingType", optional, tag = "4")]
    pub encoding: ::core::option::Option<i32>,
    /// Optional decoded content type (e.g., JSON, HTML)
    #[prost(enumeration = "DecodedType", optional, tag = "5")]
    pub decoded_type: ::core::option::Option<i32>,
    /// Match importance for test matching (0.0 to 1.0)
    /// 0.0 = lowest importance, 1.0 = highest importance
    #[prost(double, optional, tag = "6")]
    pub match_importance: ::core::option::Option<f64>,
}
/// JSON schema type enumeration
/// Language-agnostic type classification for JSON values
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JsonSchemaType {
    Unspecified = 0,
    Number = 1,
    String = 2,
    Boolean = 3,
    Null = 4,
    Undefined = 5,
    Object = 6,
    OrderedList = 7,
    UnorderedList = 8,
    Function = 9,
}
impl JsonSchemaType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "JSON_SCHEMA_TYPE_UNSPECIFIED",
            Self::Number => "JSON_SCHEMA_TYPE_NUMBER",
            Self::String => "JSON_SCHEMA_TYPE_STRING",
            Self::Boolean => "JSON_SCHEMA_TYPE_BOOLEAN",
            Self::Null => "JSON_SCHEMA_TYPE_NULL",
            Self::Undefined => "JSON_SCHEMA_TYPE_UNDEFINED",
            Self::Object => "JSON_SCHEMA_TYPE_OBJECT",
            Self::OrderedList => "JSON_SCHEMA_TYPE_ORDERED_LIST",
            Self::UnorderedList => "JSON_SCHEMA_TYPE_UNORDERED_LIST",
            Self::Function => "JSON_SCHEMA_TYPE_FUNCTION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "JSON_SCHEMA_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "JSON_SCHEMA_TYPE_NUMBER" => Some(Self::Number),
            "JSON_SCHEMA_TYPE_STRING" => Some(Self::String),
            "JSON_SCHEMA_TYPE_BOOLEAN" => Some(Self::Boolean),
            "JSON_SCHEMA_TYPE_NULL" => Some(Self::Null),
            "JSON_SCHEMA_TYPE_UNDEFINED" => Some(Self::Undefined),
            "JSON_SCHEMA_TYPE_OBJECT" => Some(Self::Object),
            "JSON_SCHEMA_TYPE_ORDERED_LIST" => Some(Self::OrderedList),
            "JSON_SCHEMA_TYPE_UNORDERED_LIST" => Some(Self::UnorderedList),
            "JSON_SCHEMA_TYPE_FUNCTION" => Some(Self::Function),
            _ => None,
        }
    }
}
/// Encoding type for data serialization
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EncodingType {
    Unspecified = 0,
    Base64 = 1,
}
impl EncodingType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ENCODING_TYPE_UNSPECIFIED",
            Self::Base64 => "ENCODING_TYPE_BASE64",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENCODING_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ENCODING_TYPE_BASE64" => Some(Self::Base64),
            _ => None,
        }
    }
}
/// Decoded content type classification
/// Describes the semantic type of decoded content
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DecodedType {
    Unspecified = 0,
    Json = 1,
    Html = 2,
    Css = 3,
    Javascript = 4,
    Xml = 5,
    Yaml = 6,
    Markdown = 7,
    Csv = 8,
    Sql = 9,
    Graphql = 10,
    PlainText = 11,
    FormData = 12,
    MultipartForm = 13,
    Pdf = 14,
    Audio = 15,
    Video = 16,
    Gzip = 17,
    Binary = 18,
    Jpeg = 19,
    Png = 20,
    Gif = 21,
    Webp = 22,
    Svg = 23,
    Zip = 24,
}
impl DecodedType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DECODED_TYPE_UNSPECIFIED",
            Self::Json => "DECODED_TYPE_JSON",
            Self::Html => "DECODED_TYPE_HTML",
            Self::Css => "DECODED_TYPE_CSS",
            Self::Javascript => "DECODED_TYPE_JAVASCRIPT",
            Self::Xml => "DECODED_TYPE_XML",
            Self::Yaml => "DECODED_TYPE_YAML",
            Self::Markdown => "DECODED_TYPE_MARKDOWN",
            Self::Csv => "DECODED_TYPE_CSV",
            Self::Sql => "DECODED_TYPE_SQL",
            Self::Graphql => "DECODED_TYPE_GRAPHQL",
            Self::PlainText => "DECODED_TYPE_PLAIN_TEXT",
            Self::FormData => "DECODED_TYPE_FORM_DATA",
            Self::MultipartForm => "DECODED_TYPE_MULTIPART_FORM",
            Self::Pdf => "DECODED_TYPE_PDF",
            Self::Audio => "DECODED_TYPE_AUDIO",
            Self::Video => "DECODED_TYPE_VIDEO",
            Self::Gzip => "DECODED_TYPE_GZIP",
            Self::Binary => "DECODED_TYPE_BINARY",
            Self::Jpeg => "DECODED_TYPE_JPEG",
            Self::Png => "DECODED_TYPE_PNG",
            Self::Gif => "DECODED_TYPE_GIF",
            Self::Webp => "DECODED_TYPE_WEBP",
            Self::Svg => "DECODED_TYPE_SVG",
            Self::Zip => "DECODED_TYPE_ZIP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DECODED_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "DECODED_TYPE_JSON" => Some(Self::Json),
            "DECODED_TYPE_HTML" => Some(Self::Html),
            "DECODED_TYPE_CSS" => Some(Self::Css),
            "DECODED_TYPE_JAVASCRIPT" => Some(Self::Javascript),
            "DECODED_TYPE_XML" => Some(Self::Xml),
            "DECODED_TYPE_YAML" => Some(Self::Yaml),
            "DECODED_TYPE_MARKDOWN" => Some(Self::Markdown),
            "DECODED_TYPE_CSV" => Some(Self::Csv),
            "DECODED_TYPE_SQL" => Some(Self::Sql),
            "DECODED_TYPE_GRAPHQL" => Some(Self::Graphql),
            "DECODED_TYPE_PLAIN_TEXT" => Some(Self::PlainText),
            "DECODED_TYPE_FORM_DATA" => Some(Self::FormData),
            "DECODED_TYPE_MULTIPART_FORM" => Some(Self::MultipartForm),
            "DECODED_TYPE_PDF" => Some(Self::Pdf),
            "DECODED_TYPE_AUDIO" => Some(Self::Audio),
            "DECODED_TYPE_VIDEO" => Some(Self::Video),
            "DECODED_TYPE_GZIP" => Some(Self::Gzip),
            "DECODED_TYPE_BINARY" => Some(Self::Binary),
            "DECODED_TYPE_JPEG" => Some(Self::Jpeg),
            "DECODED_TYPE_PNG" => Some(Self::Png),
            "DECODED_TYPE_GIF" => Some(Self::Gif),
            "DECODED_TYPE_WEBP" => Some(Self::Webp),
            "DECODED_TYPE_SVG" => Some(Self::Svg),
            "DECODED_TYPE_ZIP" => Some(Self::Zip),
            _ => None,
        }
    }
}
/// Universal span structure that works for all instrumentation types
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Span {
    /// Core span identity
    #[prost(string, tag = "1")]
    pub trace_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub span_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub parent_span_id: ::prost::alloc::string::String,
    /// Visual name
    ///
    /// "api/process_commit", "update UserQuery", "pg.query"
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    /// Instrumentation identity
    ///
    /// "http", "pg", "mysql", "redis", "fetch"
    #[prost(string, tag = "5")]
    pub package_name: ::prost::alloc::string::String,
    /// instrumentation class name
    #[prost(string, tag = "6")]
    pub instrumentation_name: ::prost::alloc::string::String,
    /// "GET", "query", "execute", "get", etc.
    #[prost(string, tag = "7")]
    pub submodule_name: ::prost::alloc::string::String,
    /// Package type classification
    ///
    /// Enum classification of package type
    #[prost(enumeration = "PackageType", tag = "8")]
    pub package_type: i32,
    /// Input/output data
    ///
    /// Request/query/command data
    #[prost(message, optional, tag = "9")]
    pub input_value: ::core::option::Option<::prost_types::Struct>,
    /// Response/result data
    #[prost(message, optional, tag = "10")]
    pub output_value: ::core::option::Option<::prost_types::Struct>,
    /// Schema definition for input
    #[prost(message, optional, tag = "11")]
    pub input_schema: ::core::option::Option<JsonSchema>,
    /// Schema definition for output
    #[prost(message, optional, tag = "12")]
    pub output_schema: ::core::option::Option<JsonSchema>,
    /// Hash-based matching and validation
    ///
    /// Hash of input schema for validation
    #[prost(string, tag = "13")]
    pub input_schema_hash: ::prost::alloc::string::String,
    /// Hash of output schema for validation
    #[prost(string, tag = "14")]
    pub output_schema_hash: ::prost::alloc::string::String,
    /// Hash of input_value for matching
    #[prost(string, tag = "15")]
    pub input_value_hash: ::prost::alloc::string::String,
    /// Hash of output_value
    #[prost(string, tag = "16")]
    pub output_value_hash: ::prost::alloc::string::String,
    /// Span metadata
    ///
    /// OpenTelemetry-compatible span kind
    #[prost(enumeration = "SpanKind", tag = "17")]
    pub kind: i32,
    /// Span completion status
    #[prost(message, optional, tag = "18")]
    pub status: ::core::option::Option<SpanStatus>,
    /// Whether the span is a before user marking app as ready
    #[prost(bool, tag = "19")]
    pub is_pre_app_start: bool,
    /// Timing information
    ///
    /// Primary timestamp
    #[prost(message, optional, tag = "20")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Primary duration
    #[prost(message, optional, tag = "21")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
    /// Span relationships and state
    #[prost(bool, tag = "22")]
    pub is_root_span: bool,
    /// Additional metadata
    #[prost(message, optional, tag = "23")]
    pub metadata: ::core::option::Option<::prost_types::Struct>,
    /// Environment information
    ///
    /// Environment name (e.g., "production", "staging", "development")
    #[prost(string, optional, tag = "24")]
    pub environment: ::core::option::Option<::prost::alloc::string::String>,
    /// Database record ID (used for caching and batch fetching)
    #[prost(string, optional, tag = "25")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Span completion status
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SpanStatus {
    #[prost(enumeration = "StatusCode", tag = "1")]
    pub code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Span events (logs) - optional
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpanEvent {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, message", tag = "3")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost_types::Value,
    >,
}
/// Span links - optional
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpanLink {
    #[prost(string, tag = "1")]
    pub trace_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub span_id: ::prost::alloc::string::String,
    #[prost(map = "string, message", tag = "3")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost_types::Value,
    >,
}
/// Trace collection
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Trace {
    #[prost(string, tag = "1")]
    pub trace_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub spans: ::prost::alloc::vec::Vec<Span>,
    #[prost(message, optional, tag = "3")]
    pub started_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub completed_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Trace-level metadata
    #[prost(map = "string, string", tag = "5")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Similarity candidate for ranking matches
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimilarityCandidate {
    #[prost(string, tag = "1")]
    pub span_id: ::prost::alloc::string::String,
    #[prost(float, tag = "2")]
    pub score: f32,
}
/// Match level information
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MatchLevel {
    /// How the match was found
    #[prost(enumeration = "MatchType", tag = "1")]
    pub match_type: i32,
    /// Scope of where the match was found
    #[prost(enumeration = "MatchScope", tag = "2")]
    pub match_scope: i32,
    /// Natural language description for match
    #[prost(string, tag = "3")]
    pub match_description: ::prost::alloc::string::String,
    /// Similarity scoring fields (populated when multiple matches exist)
    ///
    /// The similarity score of the selected match (0.0-1.0)
    #[prost(float, optional, tag = "4")]
    pub similarity_score: ::core::option::Option<f32>,
    /// Top 5 alternative matches with scores
    #[prost(message, repeated, tag = "5")]
    pub top_candidates: ::prost::alloc::vec::Vec<SimilarityCandidate>,
}
/// Package type classification enum
/// Langauge agnostic
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PackageType {
    Unspecified = 0,
    /// HTTP-based operations
    Http = 1,
    /// GraphQL operations
    Graphql = 2,
    /// gRPC operations
    Grpc = 3,
    /// PostgreSQL operations
    Pg = 4,
    /// MySQL operations
    Mysql = 5,
    /// MongoDB operations
    Mongodb = 6,
    /// Redis caching operations
    Redis = 7,
    /// Apache Kafka messaging
    Kafka = 8,
    /// RabbitMQ messaging
    Rabbitmq = 9,
    /// Firestore operations
    Firestore = 10,
    /// Prisma operations
    Prisma = 11,
}
impl PackageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PACKAGE_TYPE_UNSPECIFIED",
            Self::Http => "PACKAGE_TYPE_HTTP",
            Self::Graphql => "PACKAGE_TYPE_GRAPHQL",
            Self::Grpc => "PACKAGE_TYPE_GRPC",
            Self::Pg => "PACKAGE_TYPE_PG",
            Self::Mysql => "PACKAGE_TYPE_MYSQL",
            Self::Mongodb => "PACKAGE_TYPE_MONGODB",
            Self::Redis => "PACKAGE_TYPE_REDIS",
            Self::Kafka => "PACKAGE_TYPE_KAFKA",
            Self::Rabbitmq => "PACKAGE_TYPE_RABBITMQ",
            Self::Firestore => "PACKAGE_TYPE_FIRESTORE",
            Self::Prisma => "PACKAGE_TYPE_PRISMA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PACKAGE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PACKAGE_TYPE_HTTP" => Some(Self::Http),
            "PACKAGE_TYPE_GRAPHQL" => Some(Self::Graphql),
            "PACKAGE_TYPE_GRPC" => Some(Self::Grpc),
            "PACKAGE_TYPE_PG" => Some(Self::Pg),
            "PACKAGE_TYPE_MYSQL" => Some(Self::Mysql),
            "PACKAGE_TYPE_MONGODB" => Some(Self::Mongodb),
            "PACKAGE_TYPE_REDIS" => Some(Self::Redis),
            "PACKAGE_TYPE_KAFKA" => Some(Self::Kafka),
            "PACKAGE_TYPE_RABBITMQ" => Some(Self::Rabbitmq),
            "PACKAGE_TYPE_FIRESTORE" => Some(Self::Firestore),
            "PACKAGE_TYPE_PRISMA" => Some(Self::Prisma),
            _ => None,
        }
    }
}
/// OpenTelemetry-compatible span kinds
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SpanKind {
    Unspecified = 0,
    /// Internal operation
    Internal = 1,
    /// Server-side operation
    Server = 2,
    /// Client-side operation
    Client = 3,
    /// Message producer
    Producer = 4,
    /// Message consumer
    Consumer = 5,
}
impl SpanKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SPAN_KIND_UNSPECIFIED",
            Self::Internal => "SPAN_KIND_INTERNAL",
            Self::Server => "SPAN_KIND_SERVER",
            Self::Client => "SPAN_KIND_CLIENT",
            Self::Producer => "SPAN_KIND_PRODUCER",
            Self::Consumer => "SPAN_KIND_CONSUMER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SPAN_KIND_UNSPECIFIED" => Some(Self::Unspecified),
            "SPAN_KIND_INTERNAL" => Some(Self::Internal),
            "SPAN_KIND_SERVER" => Some(Self::Server),
            "SPAN_KIND_CLIENT" => Some(Self::Client),
            "SPAN_KIND_PRODUCER" => Some(Self::Producer),
            "SPAN_KIND_CONSUMER" => Some(Self::Consumer),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StatusCode {
    /// Default state
    Unspecified = 0,
    /// Success
    Ok = 1,
    /// Error occurred
    Error = 2,
}
impl StatusCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "STATUS_CODE_UNSPECIFIED",
            Self::Ok => "STATUS_CODE_OK",
            Self::Error => "STATUS_CODE_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATUS_CODE_UNSPECIFIED" => Some(Self::Unspecified),
            "STATUS_CODE_OK" => Some(Self::Ok),
            "STATUS_CODE_ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
/// Match scope - where the match was found
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MatchScope {
    Unspecified = 0,
    Trace = 1,
    Global = 2,
}
impl MatchScope {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "MATCH_SCOPE_UNSPECIFIED",
            Self::Trace => "MATCH_SCOPE_TRACE",
            Self::Global => "MATCH_SCOPE_GLOBAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MATCH_SCOPE_UNSPECIFIED" => Some(Self::Unspecified),
            "MATCH_SCOPE_TRACE" => Some(Self::Trace),
            "MATCH_SCOPE_GLOBAL" => Some(Self::Global),
            _ => None,
        }
    }
}
/// Match type - how the match was found
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MatchType {
    Unspecified = 0,
    InputValueHash = 1,
    InputValueHashReducedSchema = 2,
    InputSchemaHash = 3,
    InputSchemaHashReducedSchema = 4,
    Fuzzy = 5,
    Fallback = 6,
}
impl MatchType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "MATCH_TYPE_UNSPECIFIED",
            Self::InputValueHash => "MATCH_TYPE_INPUT_VALUE_HASH",
            Self::InputValueHashReducedSchema => {
                "MATCH_TYPE_INPUT_VALUE_HASH_REDUCED_SCHEMA"
            }
            Self::InputSchemaHash => "MATCH_TYPE_INPUT_SCHEMA_HASH",
            Self::InputSchemaHashReducedSchema => {
                "MATCH_TYPE_INPUT_SCHEMA_HASH_REDUCED_SCHEMA"
            }
            Self::Fuzzy => "MATCH_TYPE_FUZZY",
            Self::Fallback => "MATCH_TYPE_FALLBACK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MATCH_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "MATCH_TYPE_INPUT_VALUE_HASH" => Some(Self::InputValueHash),
            "MATCH_TYPE_INPUT_VALUE_HASH_REDUCED_SCHEMA" => {
                Some(Self::InputValueHashReducedSchema)
            }
            "MATCH_TYPE_INPUT_SCHEMA_HASH" => Some(Self::InputSchemaHash),
            "MATCH_TYPE_INPUT_SCHEMA_HASH_REDUCED_SCHEMA" => {
                Some(Self::InputSchemaHashReducedSchema)
            }
            "MATCH_TYPE_FUZZY" => Some(Self::Fuzzy),
            "MATCH_TYPE_FALLBACK" => Some(Self::Fallback),
            _ => None,
        }
    }
}
/// SDK connection handshake
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectRequest {
    #[prost(string, tag = "1")]
    pub service_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub sdk_version: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub min_cli_version: ::prost::alloc::string::String,
    /// Additional metadata (JSON-serializable)
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<::prost_types::Struct>,
    /// SDK runtime (node, python)
    #[prost(enumeration = "Runtime", tag = "5")]
    pub runtime: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub error: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMockRequest {
    /// For async correlation (used in CLI)
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    /// Trace/test identifier
    #[prost(string, tag = "2")]
    pub test_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub outbound_span: ::core::option::Option<Span>,
    #[prost(string, tag = "4")]
    pub stack_trace: ::prost::alloc::string::String,
    /// "GET", "query", "execute", "get", etc.
    #[prost(string, tag = "5")]
    pub operation: ::prost::alloc::string::String,
    /// Generic key-value metadata
    #[prost(map = "string, string", tag = "6")]
    pub tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "7")]
    pub requested_at: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMockResponse {
    /// Correlate with request
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    /// Whether mock was found
    #[prost(bool, tag = "2")]
    pub found: bool,
    /// Opaque response data - CLI returns as-is from stored spans
    ///
    /// Response payload
    #[prost(message, optional, tag = "3")]
    pub response_data: ::core::option::Option<::prost_types::Struct>,
    /// Response metadata (headers, status, etc.)
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<::prost_types::Struct>,
    /// Error information
    ///
    /// Error message if not found
    #[prost(string, tag = "5")]
    pub error: ::prost::alloc::string::String,
    /// Error classification
    #[prost(string, tag = "6")]
    pub error_code: ::prost::alloc::string::String,
    /// Mock metadata
    ///
    /// Which span was matched
    #[prost(string, tag = "7")]
    pub matched_span_id: ::prost::alloc::string::String,
    /// When the match occurred
    #[prost(message, optional, tag = "8")]
    pub matched_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Match information (populated when found=true)
    #[prost(message, optional, tag = "9")]
    pub match_level: ::core::option::Option<MatchLevel>,
}
/// Message types for the Unix socket protocol
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SdkMessage {
    #[prost(enumeration = "MessageType", tag = "1")]
    pub r#type: i32,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(oneof = "sdk_message::Payload", tags = "3, 4, 5, 6, 7, 8")]
    pub payload: ::core::option::Option<sdk_message::Payload>,
}
/// Nested message and enum types in `SDKMessage`.
pub mod sdk_message {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "3")]
        ConnectRequest(super::ConnectRequest),
        #[prost(message, tag = "4")]
        GetMockRequest(super::GetMockRequest),
        #[prost(message, tag = "5")]
        SendInboundSpanForReplayRequest(super::SendInboundSpanForReplayRequest),
        #[prost(message, tag = "6")]
        SendAlertRequest(super::SendAlertRequest),
        #[prost(message, tag = "7")]
        EnvVarRequest(super::EnvVarRequest),
        #[prost(message, tag = "8")]
        SetTimeTravelResponse(super::SetTimeTravelResponse),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CliMessage {
    #[prost(enumeration = "MessageType", tag = "1")]
    pub r#type: i32,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(oneof = "cli_message::Payload", tags = "3, 4, 5, 6, 7")]
    pub payload: ::core::option::Option<cli_message::Payload>,
}
/// Nested message and enum types in `CLIMessage`.
pub mod cli_message {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "3")]
        ConnectResponse(super::ConnectResponse),
        #[prost(message, tag = "4")]
        GetMockResponse(super::GetMockResponse),
        #[prost(message, tag = "5")]
        SendInboundSpanForReplayResponse(super::SendInboundSpanForReplayResponse),
        #[prost(message, tag = "6")]
        EnvVarResponse(super::EnvVarResponse),
        #[prost(message, tag = "7")]
        SetTimeTravelRequest(super::SetTimeTravelRequest),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendInboundSpanForReplayRequest {
    #[prost(message, optional, tag = "1")]
    pub span: ::core::option::Option<Span>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SendInboundSpanForReplayResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SendAlertRequest {
    #[prost(oneof = "send_alert_request::Alert", tags = "1, 2")]
    pub alert: ::core::option::Option<send_alert_request::Alert>,
}
/// Nested message and enum types in `SendAlertRequest`.
pub mod send_alert_request {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Alert {
        #[prost(message, tag = "1")]
        VersionMismatch(super::InstrumentationVersionMismatchAlert),
        #[prost(message, tag = "2")]
        UnpatchedDependency(super::UnpatchedDependencyAlert),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstrumentationVersionMismatchAlert {
    #[prost(string, tag = "1")]
    pub module_name: ::prost::alloc::string::String,
    /// Can be empty if version not found
    #[prost(string, tag = "2")]
    pub requested_version: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub supported_versions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub sdk_version: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnpatchedDependencyAlert {
    #[prost(string, tag = "1")]
    pub stack_trace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub trace_test_server_span_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub sdk_version: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EnvVarRequest {
    #[prost(string, tag = "1")]
    pub trace_test_server_span_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnvVarResponse {
    #[prost(map = "string, string", tag = "1")]
    pub env_vars: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Request from CLI to SDK to start time travel before request replay
/// Currently only used for python SDK
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTimeTravelRequest {
    /// Unix timestamp in seconds (can include fractional seconds)
    #[prost(double, tag = "1")]
    pub timestamp_seconds: f64,
    /// The trace ID this time travel is for (for debugging/logging)
    #[prost(string, tag = "2")]
    pub trace_id: ::prost::alloc::string::String,
    /// Description of why this timestamp was chosen: "first_span" or "server_span"
    #[prost(string, tag = "3")]
    pub timestamp_source: ::prost::alloc::string::String,
}
/// Response from SDK acknowledging time travel was set
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetTimeTravelResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub error: ::prost::alloc::string::String,
}
/// SDK runtime environment
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Runtime {
    Unspecified = 0,
    Node = 1,
    Python = 2,
}
impl Runtime {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RUNTIME_UNSPECIFIED",
            Self::Node => "RUNTIME_NODE",
            Self::Python => "RUNTIME_PYTHON",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RUNTIME_UNSPECIFIED" => Some(Self::Unspecified),
            "RUNTIME_NODE" => Some(Self::Node),
            "RUNTIME_PYTHON" => Some(Self::Python),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MessageType {
    Unspecified = 0,
    SdkConnect = 1,
    MockRequest = 2,
    InboundSpan = 3,
    Alert = 4,
    EnvVarRequest = 5,
    SetTimeTravel = 6,
}
impl MessageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "MESSAGE_TYPE_UNSPECIFIED",
            Self::SdkConnect => "MESSAGE_TYPE_SDK_CONNECT",
            Self::MockRequest => "MESSAGE_TYPE_MOCK_REQUEST",
            Self::InboundSpan => "MESSAGE_TYPE_INBOUND_SPAN",
            Self::Alert => "MESSAGE_TYPE_ALERT",
            Self::EnvVarRequest => "MESSAGE_TYPE_ENV_VAR_REQUEST",
            Self::SetTimeTravel => "MESSAGE_TYPE_SET_TIME_TRAVEL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MESSAGE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "MESSAGE_TYPE_SDK_CONNECT" => Some(Self::SdkConnect),
            "MESSAGE_TYPE_MOCK_REQUEST" => Some(Self::MockRequest),
            "MESSAGE_TYPE_INBOUND_SPAN" => Some(Self::InboundSpan),
            "MESSAGE_TYPE_ALERT" => Some(Self::Alert),
            "MESSAGE_TYPE_ENV_VAR_REQUEST" => Some(Self::EnvVarRequest),
            "MESSAGE_TYPE_SET_TIME_TRAVEL" => Some(Self::SetTimeTravel),
            _ => None,
        }
    }
}
