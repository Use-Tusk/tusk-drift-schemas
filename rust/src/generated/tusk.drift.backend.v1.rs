// This file is @generated by prost-build.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAuthInfoRequest {
    #[prost(string, optional, tag = "1")]
    pub client_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserAuthInfo {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "UserType", tag = "2")]
    pub r#type: i32,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "4")]
    pub email: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub code_hosting_username: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthInfoClient {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub domain: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub feature_flags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "5")]
    pub code_hosting_resources: ::prost::alloc::vec::Vec<CodeHostingResource>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CodeHostingResource {
    #[prost(int64, tag = "1")]
    pub id: i64,
    #[prost(enumeration = "CodeHostingResourceType", tag = "2")]
    pub r#type: i32,
    #[prost(string, tag = "3")]
    pub external_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAuthInfoResponse {
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<UserAuthInfo>,
    #[prost(message, repeated, tag = "2")]
    pub clients: ::prost::alloc::vec::Vec<AuthInfoClient>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateObservableServiceRequest {
    #[prost(string, tag = "1")]
    pub repo_owner_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub repo_name: ::prost::alloc::string::String,
    #[prost(enumeration = "ServiceType", tag = "3")]
    pub service_type: i32,
    #[prost(string, optional, tag = "4")]
    pub app_dir: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateObservableServiceResponseSuccess {
    #[prost(string, tag = "1")]
    pub observable_service_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateObservableServiceResponseError {
    #[prost(enumeration = "CreateObservableServiceResponseErrorCode", tag = "1")]
    pub code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateObservableServiceResponse {
    #[prost(oneof = "create_observable_service_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<create_observable_service_response::Response>,
}
/// Nested message and enum types in `CreateObservableServiceResponse`.
pub mod create_observable_service_response {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Success(super::CreateObservableServiceResponseSuccess),
        #[prost(message, tag = "2")]
        Error(super::CreateObservableServiceResponseError),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VerifyRepoAccessRequest {
    #[prost(string, tag = "1")]
    pub repo_owner_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub repo_name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VerifyRepoAccessResponseSuccess {
    #[prost(int64, tag = "1")]
    pub repo_id: i64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VerifyRepoAccessResponseError {
    #[prost(enumeration = "VerifyRepoAccessResponseErrorCode", tag = "1")]
    pub code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VerifyRepoAccessResponse {
    #[prost(oneof = "verify_repo_access_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<verify_repo_access_response::Response>,
}
/// Nested message and enum types in `VerifyRepoAccessResponse`.
pub mod verify_repo_access_response {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Success(super::VerifyRepoAccessResponseSuccess),
        #[prost(message, tag = "2")]
        Error(super::VerifyRepoAccessResponseError),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateApiKeyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateApiKeyResponse {
    #[prost(oneof = "create_api_key_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<create_api_key_response::Response>,
}
/// Nested message and enum types in `CreateApiKeyResponse`.
pub mod create_api_key_response {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Success(super::CreateApiKeyResponseSuccess),
        #[prost(message, tag = "2")]
        Error(super::CreateApiKeyResponseError),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateApiKeyResponseSuccess {
    #[prost(string, tag = "1")]
    pub api_key_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub api_key: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateApiKeyResponseError {
    #[prost(enumeration = "CreateApiKeyResponseErrorCode", tag = "1")]
    pub code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetObservableServiceInfoRequest {
    #[prost(string, tag = "1")]
    pub observable_service_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetObservableServiceInfoResponseSuccess {
    #[prost(string, tag = "1")]
    pub observable_service_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub default_branch: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub repo_owner: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub repo_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetObservableServiceInfoResponseError {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetObservableServiceInfoResponse {
    #[prost(oneof = "get_observable_service_info_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<get_observable_service_info_response::Response>,
}
/// Nested message and enum types in `GetObservableServiceInfoResponse`.
pub mod get_observable_service_info_response {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Success(super::GetObservableServiceInfoResponseSuccess),
        #[prost(message, tag = "2")]
        Error(super::GetObservableServiceInfoResponseError),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UserType {
    Unspecified = 0,
    User = 1,
    ApiKey = 2,
}
impl UserType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "USER_TYPE_UNSPECIFIED",
            Self::User => "USER_TYPE_USER",
            Self::ApiKey => "USER_TYPE_API_KEY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "USER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "USER_TYPE_USER" => Some(Self::User),
            "USER_TYPE_API_KEY" => Some(Self::ApiKey),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CodeHostingResourceType {
    Unspecified = 0,
    Github = 1,
    Gitlab = 2,
}
impl CodeHostingResourceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CODE_HOSTING_RESOURCE_TYPE_UNSPECIFIED",
            Self::Github => "CODE_HOSTING_RESOURCE_TYPE_GITHUB",
            Self::Gitlab => "CODE_HOSTING_RESOURCE_TYPE_GITLAB",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CODE_HOSTING_RESOURCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CODE_HOSTING_RESOURCE_TYPE_GITHUB" => Some(Self::Github),
            "CODE_HOSTING_RESOURCE_TYPE_GITLAB" => Some(Self::Gitlab),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ServiceType {
    Unspecified = 0,
    Node = 1,
    Python = 2,
}
impl ServiceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SERVICE_TYPE_UNSPECIFIED",
            Self::Node => "SERVICE_TYPE_NODE",
            Self::Python => "SERVICE_TYPE_PYTHON",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SERVICE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "SERVICE_TYPE_NODE" => Some(Self::Node),
            "SERVICE_TYPE_PYTHON" => Some(Self::Python),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CreateObservableServiceResponseErrorCode {
    Unspecified = 0,
    Internal = 1,
    NotAuthorized = 2,
    NoCodeHostingResource = 3,
    NoRepoFound = 4,
}
impl CreateObservableServiceResponseErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => {
                "CREATE_OBSERVABLE_SERVICE_RESPONSE_ERROR_CODE_UNSPECIFIED"
            }
            Self::Internal => "CREATE_OBSERVABLE_SERVICE_RESPONSE_ERROR_CODE_INTERNAL",
            Self::NotAuthorized => {
                "CREATE_OBSERVABLE_SERVICE_RESPONSE_ERROR_CODE_NOT_AUTHORIZED"
            }
            Self::NoCodeHostingResource => {
                "CREATE_OBSERVABLE_SERVICE_RESPONSE_ERROR_CODE_NO_CODE_HOSTING_RESOURCE"
            }
            Self::NoRepoFound => {
                "CREATE_OBSERVABLE_SERVICE_RESPONSE_ERROR_CODE_NO_REPO_FOUND"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CREATE_OBSERVABLE_SERVICE_RESPONSE_ERROR_CODE_UNSPECIFIED" => {
                Some(Self::Unspecified)
            }
            "CREATE_OBSERVABLE_SERVICE_RESPONSE_ERROR_CODE_INTERNAL" => {
                Some(Self::Internal)
            }
            "CREATE_OBSERVABLE_SERVICE_RESPONSE_ERROR_CODE_NOT_AUTHORIZED" => {
                Some(Self::NotAuthorized)
            }
            "CREATE_OBSERVABLE_SERVICE_RESPONSE_ERROR_CODE_NO_CODE_HOSTING_RESOURCE" => {
                Some(Self::NoCodeHostingResource)
            }
            "CREATE_OBSERVABLE_SERVICE_RESPONSE_ERROR_CODE_NO_REPO_FOUND" => {
                Some(Self::NoRepoFound)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VerifyRepoAccessResponseErrorCode {
    Unspecified = 0,
    Internal = 1,
    NotAuthorized = 2,
    NoCodeHostingResource = 3,
    RepoNotFound = 4,
}
impl VerifyRepoAccessResponseErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "VERIFY_REPO_ACCESS_RESPONSE_ERROR_CODE_UNSPECIFIED",
            Self::Internal => "VERIFY_REPO_ACCESS_RESPONSE_ERROR_CODE_INTERNAL",
            Self::NotAuthorized => {
                "VERIFY_REPO_ACCESS_RESPONSE_ERROR_CODE_NOT_AUTHORIZED"
            }
            Self::NoCodeHostingResource => {
                "VERIFY_REPO_ACCESS_RESPONSE_ERROR_CODE_NO_CODE_HOSTING_RESOURCE"
            }
            Self::RepoNotFound => "VERIFY_REPO_ACCESS_RESPONSE_ERROR_CODE_REPO_NOT_FOUND",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VERIFY_REPO_ACCESS_RESPONSE_ERROR_CODE_UNSPECIFIED" => {
                Some(Self::Unspecified)
            }
            "VERIFY_REPO_ACCESS_RESPONSE_ERROR_CODE_INTERNAL" => Some(Self::Internal),
            "VERIFY_REPO_ACCESS_RESPONSE_ERROR_CODE_NOT_AUTHORIZED" => {
                Some(Self::NotAuthorized)
            }
            "VERIFY_REPO_ACCESS_RESPONSE_ERROR_CODE_NO_CODE_HOSTING_RESOURCE" => {
                Some(Self::NoCodeHostingResource)
            }
            "VERIFY_REPO_ACCESS_RESPONSE_ERROR_CODE_REPO_NOT_FOUND" => {
                Some(Self::RepoNotFound)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CreateApiKeyResponseErrorCode {
    Unspecified = 0,
    Internal = 1,
    NotAuthorized = 2,
}
impl CreateApiKeyResponseErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CREATE_API_KEY_RESPONSE_ERROR_CODE_UNSPECIFIED",
            Self::Internal => "CREATE_API_KEY_RESPONSE_ERROR_CODE_INTERNAL",
            Self::NotAuthorized => "CREATE_API_KEY_RESPONSE_ERROR_CODE_NOT_AUTHORIZED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CREATE_API_KEY_RESPONSE_ERROR_CODE_UNSPECIFIED" => Some(Self::Unspecified),
            "CREATE_API_KEY_RESPONSE_ERROR_CODE_INTERNAL" => Some(Self::Internal),
            "CREATE_API_KEY_RESPONSE_ERROR_CODE_NOT_AUTHORIZED" => {
                Some(Self::NotAuthorized)
            }
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportSpansRequest {
    #[prost(string, tag = "1")]
    pub observable_service_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub environment: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub sdk_version: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub sdk_instance_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub spans: ::prost::alloc::vec::Vec<super::super::core::v1::Span>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExportSpansResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    /// TODO: Add field to indicate number of spans saved?
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetGlobalSpansRequest {
    #[prost(string, tag = "1")]
    pub observable_service_id: ::prost::alloc::string::String,
    /// Optional since first page will have no cursor
    #[prost(string, optional, tag = "2")]
    pub pagination_cursor: ::core::option::Option<::prost::alloc::string::String>,
    /// Server should provide next cursor based on this page size
    #[prost(int32, tag = "3")]
    pub page_size: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGlobalSpansResponseSuccess {
    #[prost(message, repeated, tag = "1")]
    pub spans: ::prost::alloc::vec::Vec<super::super::core::v1::Span>,
    #[prost(string, optional, tag = "2")]
    pub next_cursor: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, tag = "3")]
    pub total_count: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetGlobalSpansResponseError {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGlobalSpansResponse {
    #[prost(oneof = "get_global_spans_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<get_global_spans_response::Response>,
}
/// Nested message and enum types in `GetGlobalSpansResponse`.
pub mod get_global_spans_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Success(super::GetGlobalSpansResponseSuccess),
        #[prost(message, tag = "2")]
        Error(super::GetGlobalSpansResponseError),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPreAppStartSpansRequest {
    #[prost(string, tag = "1")]
    pub observable_service_id: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub pagination_cursor: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPreAppStartSpansResponseSuccess {
    #[prost(message, repeated, tag = "1")]
    pub spans: ::prost::alloc::vec::Vec<super::super::core::v1::Span>,
    #[prost(string, optional, tag = "2")]
    pub next_cursor: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, tag = "3")]
    pub total_count: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPreAppStartSpansResponseError {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPreAppStartSpansResponse {
    #[prost(oneof = "get_pre_app_start_spans_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<get_pre_app_start_spans_response::Response>,
}
/// Nested message and enum types in `GetPreAppStartSpansResponse`.
pub mod get_pre_app_start_spans_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Success(super::GetPreAppStartSpansResponseSuccess),
        #[prost(message, tag = "2")]
        Error(super::GetPreAppStartSpansResponseError),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateDriftRunRequest {
    #[prost(string, tag = "1")]
    pub observable_service_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub cli_version: ::prost::alloc::string::String,
    /// These fields are optional for validation runs
    #[prost(string, optional, tag = "3")]
    pub commit_sha: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub pr_number: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub branch_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub external_check_run_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Indicates this is a validation run on the default branch
    #[prost(bool, tag = "7")]
    pub is_validation_run: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateDriftRunResponseSuccess {
    #[prost(string, tag = "1")]
    pub drift_run_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateDriftRunResponseError {
    /// Machine-readable error code, could be an enum
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    /// Human-readable error message
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateDriftRunResponse {
    #[prost(oneof = "create_drift_run_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<create_drift_run_response::Response>,
}
/// Nested message and enum types in `CreateDriftRunResponse`.
pub mod create_drift_run_response {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Success(super::CreateDriftRunResponseSuccess),
        #[prost(message, tag = "2")]
        Error(super::CreateDriftRunResponseError),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetDriftRunTraceTestsRequest {
    #[prost(string, tag = "1")]
    pub drift_run_id: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub pagination_cursor: ::core::option::Option<::prost::alloc::string::String>,
    /// Server should provide next cursor based on this page size
    #[prost(int32, tag = "3")]
    pub page_size: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceTest {
    /// DB id
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub trace_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub server_span_recording_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub spans: ::prost::alloc::vec::Vec<super::super::core::v1::Span>,
    /// Status of the trace test (DRAFT, IN_SUITE, REMOVED)
    #[prost(enumeration = "TraceTestStatus", tag = "5")]
    pub status: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDriftRunTraceTestsResponseSuccess {
    #[prost(message, repeated, tag = "1")]
    pub trace_tests: ::prost::alloc::vec::Vec<TraceTest>,
    #[prost(string, optional, tag = "2")]
    pub next_cursor: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, tag = "3")]
    pub total_count: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetDriftRunTraceTestsResponseError {
    /// Machine-readable error code, could be an enum
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    /// Human-readable error message
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDriftRunTraceTestsResponse {
    #[prost(oneof = "get_drift_run_trace_tests_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<get_drift_run_trace_tests_response::Response>,
}
/// Nested message and enum types in `GetDriftRunTraceTestsResponse`.
pub mod get_drift_run_trace_tests_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Success(super::GetDriftRunTraceTestsResponseSuccess),
        #[prost(message, tag = "2")]
        Error(super::GetDriftRunTraceTestsResponseError),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTraceTestRequest {
    #[prost(string, tag = "1")]
    pub observable_service_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub trace_test_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTraceTestResponse {
    #[prost(oneof = "get_trace_test_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<get_trace_test_response::Response>,
}
/// Nested message and enum types in `GetTraceTestResponse`.
pub mod get_trace_test_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Success(super::GetTraceTestResponseSuccess),
        #[prost(message, tag = "2")]
        Error(super::GetTraceTestResponseError),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTraceTestResponseSuccess {
    #[prost(message, optional, tag = "1")]
    pub trace_test: ::core::option::Option<TraceTest>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTraceTestResponseError {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAllTraceTestsRequest {
    #[prost(string, tag = "1")]
    pub observable_service_id: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub pagination_cursor: ::core::option::Option<::prost::alloc::string::String>,
    /// Server should provide next cursor based on this page size
    #[prost(int32, tag = "3")]
    pub page_size: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllTraceTestsResponseSuccess {
    #[prost(message, repeated, tag = "1")]
    pub trace_tests: ::prost::alloc::vec::Vec<TraceTest>,
    #[prost(string, optional, tag = "2")]
    pub next_cursor: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, tag = "3")]
    pub total_count: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAllTraceTestsResponseError {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllTraceTestsResponse {
    #[prost(oneof = "get_all_trace_tests_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<get_all_trace_tests_response::Response>,
}
/// Nested message and enum types in `GetAllTraceTestsResponse`.
pub mod get_all_trace_tests_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Success(super::GetAllTraceTestsResponseSuccess),
        #[prost(message, tag = "2")]
        Error(super::GetAllTraceTestsResponseError),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Deviation {
    /// what field in replay span had a deviation
    #[prost(string, tag = "1")]
    pub field: ::prost::alloc::string::String,
    /// description of the deviation, primarily useful for comparing SUT
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceTestSpanResult {
    /// Create a separate table in backend for span_result_recording, but very
    /// similar schema to
    #[prost(message, optional, tag = "1")]
    pub replay_span: ::core::option::Option<super::super::core::v1::Span>,
    /// All nullable since we want to allow for no matching span_recordings
    /// This should be the DB id of the matched span_recording
    #[prost(string, optional, tag = "2")]
    pub matched_span_recording_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "3")]
    pub match_level: ::core::option::Option<super::super::core::v1::MatchLevel>,
    #[prost(string, optional, tag = "4")]
    pub stack_trace: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "5")]
    pub deviations: ::prost::alloc::vec::Vec<Deviation>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceTestResult {
    /// DB id
    #[prost(string, tag = "1")]
    pub trace_test_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub test_success: bool,
    #[prost(enumeration = "TraceTestFailureReason", optional, tag = "3")]
    pub test_failure_reason: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "4")]
    pub test_failure_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub replay_trace_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub replay_server_span_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "7")]
    pub span_results: ::prost::alloc::vec::Vec<TraceTestSpanResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadTraceTestResultsRequest {
    #[prost(string, tag = "1")]
    pub drift_run_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub cli_version: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub sdk_version: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub trace_test_results: ::prost::alloc::vec::Vec<TraceTestResult>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UploadTraceTestResultsResponseSuccess {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UploadTraceTestResultsResponseError {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UploadTraceTestResultsResponse {
    #[prost(oneof = "upload_trace_test_results_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<upload_trace_test_results_response::Response>,
}
/// Nested message and enum types in `UploadTraceTestResultsResponse`.
pub mod upload_trace_test_results_response {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Success(super::UploadTraceTestResultsResponseSuccess),
        #[prost(message, tag = "2")]
        Error(super::UploadTraceTestResultsResponseError),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateDriftRunCiStatusRequest {
    #[prost(string, tag = "1")]
    pub drift_run_id: ::prost::alloc::string::String,
    #[prost(enumeration = "DriftRunCiStatus", tag = "2")]
    pub ci_status: i32,
    #[prost(string, optional, tag = "3")]
    pub ci_status_message: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateDriftRunCiStatusResponseSuccess {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateDriftRunCiStatusResponseError {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateDriftRunCiStatusResponse {
    #[prost(oneof = "update_drift_run_ci_status_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<update_drift_run_ci_status_response::Response>,
}
/// Nested message and enum types in `UpdateDriftRunCIStatusResponse`.
pub mod update_drift_run_ci_status_response {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Success(super::UpdateDriftRunCiStatusResponseSuccess),
        #[prost(message, tag = "2")]
        Error(super::UpdateDriftRunCiStatusResponseError),
    }
}
/// GetValidationTraceTests - Get all traces for validation (DRAFT and IN_SUITE)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetValidationTraceTestsRequest {
    #[prost(string, tag = "1")]
    pub observable_service_id: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub pagination_cursor: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetValidationTraceTestsResponseSuccess {
    #[prost(message, repeated, tag = "1")]
    pub trace_tests: ::prost::alloc::vec::Vec<TraceTest>,
    #[prost(string, optional, tag = "2")]
    pub next_cursor: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, tag = "3")]
    pub total_count: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetValidationTraceTestsResponseError {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetValidationTraceTestsResponse {
    #[prost(oneof = "get_validation_trace_tests_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<get_validation_trace_tests_response::Response>,
}
/// Nested message and enum types in `GetValidationTraceTestsResponse`.
pub mod get_validation_trace_tests_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Success(super::GetValidationTraceTestsResponseSuccess),
        #[prost(message, tag = "2")]
        Error(super::GetValidationTraceTestsResponseError),
    }
}
/// GetAllTraceTestIds - Get all trace test IDs (lightweight, for cache diffing)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAllTraceTestIdsRequest {
    #[prost(string, tag = "1")]
    pub observable_service_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAllTraceTestIdsResponseSuccess {
    #[prost(string, repeated, tag = "1")]
    pub trace_test_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAllTraceTestIdsResponseError {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAllTraceTestIdsResponse {
    #[prost(oneof = "get_all_trace_test_ids_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<get_all_trace_test_ids_response::Response>,
}
/// Nested message and enum types in `GetAllTraceTestIdsResponse`.
pub mod get_all_trace_test_ids_response {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Success(super::GetAllTraceTestIdsResponseSuccess),
        #[prost(message, tag = "2")]
        Error(super::GetAllTraceTestIdsResponseError),
    }
}
/// GetTraceTestsByIds - Batch fetch trace tests by IDs
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTraceTestsByIdsRequest {
    #[prost(string, tag = "1")]
    pub observable_service_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub trace_test_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTraceTestsByIdsResponseSuccess {
    #[prost(message, repeated, tag = "1")]
    pub trace_tests: ::prost::alloc::vec::Vec<TraceTest>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTraceTestsByIdsResponseError {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTraceTestsByIdsResponse {
    #[prost(oneof = "get_trace_tests_by_ids_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<get_trace_tests_by_ids_response::Response>,
}
/// Nested message and enum types in `GetTraceTestsByIdsResponse`.
pub mod get_trace_tests_by_ids_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Success(super::GetTraceTestsByIdsResponseSuccess),
        #[prost(message, tag = "2")]
        Error(super::GetTraceTestsByIdsResponseError),
    }
}
/// GetAllPreAppStartSpanIds - Get all pre-app-start span IDs (lightweight, for cache diffing)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAllPreAppStartSpanIdsRequest {
    #[prost(string, tag = "1")]
    pub observable_service_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAllPreAppStartSpanIdsResponseSuccess {
    #[prost(string, repeated, tag = "1")]
    pub span_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAllPreAppStartSpanIdsResponseError {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAllPreAppStartSpanIdsResponse {
    #[prost(oneof = "get_all_pre_app_start_span_ids_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<
        get_all_pre_app_start_span_ids_response::Response,
    >,
}
/// Nested message and enum types in `GetAllPreAppStartSpanIdsResponse`.
pub mod get_all_pre_app_start_span_ids_response {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Success(super::GetAllPreAppStartSpanIdsResponseSuccess),
        #[prost(message, tag = "2")]
        Error(super::GetAllPreAppStartSpanIdsResponseError),
    }
}
/// GetPreAppStartSpansByIds - Batch fetch pre-app-start spans by IDs
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPreAppStartSpansByIdsRequest {
    #[prost(string, tag = "1")]
    pub observable_service_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub span_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPreAppStartSpansByIdsResponseSuccess {
    #[prost(message, repeated, tag = "1")]
    pub spans: ::prost::alloc::vec::Vec<super::super::core::v1::Span>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPreAppStartSpansByIdsResponseError {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPreAppStartSpansByIdsResponse {
    #[prost(oneof = "get_pre_app_start_spans_by_ids_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<
        get_pre_app_start_spans_by_ids_response::Response,
    >,
}
/// Nested message and enum types in `GetPreAppStartSpansByIdsResponse`.
pub mod get_pre_app_start_spans_by_ids_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Success(super::GetPreAppStartSpansByIdsResponseSuccess),
        #[prost(message, tag = "2")]
        Error(super::GetPreAppStartSpansByIdsResponseError),
    }
}
/// GetAllGlobalSpanIds - Get all global span IDs (lightweight, for cache diffing)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAllGlobalSpanIdsRequest {
    #[prost(string, tag = "1")]
    pub observable_service_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAllGlobalSpanIdsResponseSuccess {
    #[prost(string, repeated, tag = "1")]
    pub span_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAllGlobalSpanIdsResponseError {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAllGlobalSpanIdsResponse {
    #[prost(oneof = "get_all_global_span_ids_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<get_all_global_span_ids_response::Response>,
}
/// Nested message and enum types in `GetAllGlobalSpanIdsResponse`.
pub mod get_all_global_span_ids_response {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Success(super::GetAllGlobalSpanIdsResponseSuccess),
        #[prost(message, tag = "2")]
        Error(super::GetAllGlobalSpanIdsResponseError),
    }
}
/// GetGlobalSpansByIds - Batch fetch global spans by IDs
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetGlobalSpansByIdsRequest {
    #[prost(string, tag = "1")]
    pub observable_service_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub span_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGlobalSpansByIdsResponseSuccess {
    #[prost(message, repeated, tag = "1")]
    pub spans: ::prost::alloc::vec::Vec<super::super::core::v1::Span>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetGlobalSpansByIdsResponseError {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGlobalSpansByIdsResponse {
    #[prost(oneof = "get_global_spans_by_ids_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<get_global_spans_by_ids_response::Response>,
}
/// Nested message and enum types in `GetGlobalSpansByIdsResponse`.
pub mod get_global_spans_by_ids_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Success(super::GetGlobalSpansByIdsResponseSuccess),
        #[prost(message, tag = "2")]
        Error(super::GetGlobalSpansByIdsResponseError),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TraceTestStatus {
    Unspecified = 0,
    Draft = 1,
    InSuite = 2,
    Removed = 3,
}
impl TraceTestStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TRACE_TEST_STATUS_UNSPECIFIED",
            Self::Draft => "TRACE_TEST_STATUS_DRAFT",
            Self::InSuite => "TRACE_TEST_STATUS_IN_SUITE",
            Self::Removed => "TRACE_TEST_STATUS_REMOVED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRACE_TEST_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "TRACE_TEST_STATUS_DRAFT" => Some(Self::Draft),
            "TRACE_TEST_STATUS_IN_SUITE" => Some(Self::InSuite),
            "TRACE_TEST_STATUS_REMOVED" => Some(Self::Removed),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TraceTestFailureReason {
    Unspecified = 0,
    MockNotFound = 1,
    ResponseMismatch = 2,
    NoResponse = 3,
}
impl TraceTestFailureReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TRACE_TEST_FAILURE_REASON_UNSPECIFIED",
            Self::MockNotFound => "TRACE_TEST_FAILURE_REASON_MOCK_NOT_FOUND",
            Self::ResponseMismatch => "TRACE_TEST_FAILURE_REASON_RESPONSE_MISMATCH",
            Self::NoResponse => "TRACE_TEST_FAILURE_REASON_NO_RESPONSE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRACE_TEST_FAILURE_REASON_UNSPECIFIED" => Some(Self::Unspecified),
            "TRACE_TEST_FAILURE_REASON_MOCK_NOT_FOUND" => Some(Self::MockNotFound),
            "TRACE_TEST_FAILURE_REASON_RESPONSE_MISMATCH" => Some(Self::ResponseMismatch),
            "TRACE_TEST_FAILURE_REASON_NO_RESPONSE" => Some(Self::NoResponse),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DriftRunCiStatus {
    Unspecified = 0,
    Running = 1,
    Success = 2,
    Failure = 3,
}
impl DriftRunCiStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DRIFT_RUN_CI_STATUS_UNSPECIFIED",
            Self::Running => "DRIFT_RUN_CI_STATUS_RUNNING",
            Self::Success => "DRIFT_RUN_CI_STATUS_SUCCESS",
            Self::Failure => "DRIFT_RUN_CI_STATUS_FAILURE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DRIFT_RUN_CI_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "DRIFT_RUN_CI_STATUS_RUNNING" => Some(Self::Running),
            "DRIFT_RUN_CI_STATUS_SUCCESS" => Some(Self::Success),
            "DRIFT_RUN_CI_STATUS_FAILURE" => Some(Self::Failure),
            _ => None,
        }
    }
}
