// This file is @generated by prost-build.
/// PostgreSQL query request - used internally by PostgreSQL instrumentation SDK
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PostgreSqlQuery {
    /// Core query information
    ///
    /// SQL query text
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    /// Parameterized query values (always strings)
    #[prost(string, repeated, tag = "2")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// "client", "pool", etc.
    #[prost(string, tag = "3")]
    pub client_type: ::prost::alloc::string::String,
    /// Connection context
    ///
    /// Connection information
    #[prost(message, optional, tag = "4")]
    pub connection: ::core::option::Option<PostgreSqlConnection>,
    /// Query execution options
    #[prost(message, optional, tag = "5")]
    pub options: ::core::option::Option<QueryOptions>,
    /// Query metadata
    ///
    /// Unique query identifier (optional)
    #[prost(string, tag = "6")]
    pub query_id: ::prost::alloc::string::String,
    /// Custom tags for the query
    #[prost(map = "string, string", tag = "7")]
    pub tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// PostgreSQL connection information
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PostgreSqlConnection {
    /// Database name
    #[prost(string, tag = "1")]
    pub database_name: ::prost::alloc::string::String,
    /// Username (without password)
    #[prost(string, tag = "2")]
    pub username: ::prost::alloc::string::String,
    /// Host address
    #[prost(string, tag = "3")]
    pub host: ::prost::alloc::string::String,
    /// Port number
    #[prost(int32, tag = "4")]
    pub port: i32,
    /// Application name in connection
    #[prost(string, tag = "5")]
    pub application_name: ::prost::alloc::string::String,
    /// Connection identifier
    #[prost(string, tag = "6")]
    pub connection_id: ::prost::alloc::string::String,
    /// Whether SSL is enabled
    #[prost(bool, tag = "7")]
    pub ssl_enabled: bool,
    /// PostgreSQL server version
    #[prost(string, tag = "8")]
    pub server_version: ::prost::alloc::string::String,
}
/// Query execution options
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryOptions {
    /// Statement timeout in milliseconds
    #[prost(int32, tag = "1")]
    pub statement_timeout: i32,
    /// Query timeout in milliseconds
    #[prost(int32, tag = "2")]
    pub query_timeout: i32,
    /// Whether binary mode is enabled
    #[prost(bool, tag = "3")]
    pub binary_mode: bool,
    /// Cursor name (for cursor queries)
    #[prost(string, tag = "4")]
    pub cursor_name: ::prost::alloc::string::String,
    /// Fetch size for large result sets
    #[prost(int32, tag = "5")]
    pub fetch_size: i32,
    /// Whether query is read-only
    #[prost(bool, tag = "6")]
    pub read_only: bool,
    /// Custom driver options
    #[prost(map = "string, string", tag = "7")]
    pub custom_options: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// PostgreSQL query result - matches your trace data structure
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PostgreSqlResult {
    /// Core result information (from your trace data)
    ///
    /// "SELECT", "INSERT", "UPDATE", etc.
    #[prost(string, tag = "1")]
    pub command: ::prost::alloc::string::String,
    /// Number of rows affected/returned
    #[prost(int32, tag = "2")]
    pub row_count: i32,
    /// Object ID (PostgreSQL-specific, can be null)
    #[prost(int32, optional, tag = "3")]
    pub oid: ::core::option::Option<i32>,
    /// Result data
    ///
    /// Actual row data as JSON objects
    #[prost(message, repeated, tag = "4")]
    pub rows: ::prost::alloc::vec::Vec<::prost_types::Struct>,
    /// Field/column definitions
    #[prost(message, repeated, tag = "5")]
    pub fields: ::prost::alloc::vec::Vec<PostgreSqlField>,
    /// Query execution metadata
    ///
    /// Execution details
    #[prost(message, optional, tag = "6")]
    pub execution_info: ::core::option::Option<QueryExecutionInfo>,
    /// Error information (if query failed)
    ///
    /// Error details
    #[prost(message, optional, tag = "7")]
    pub error: ::core::option::Option<PostgreSqlError>,
}
/// PostgreSQL field definition (matches your trace data)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PostgreSqlField {
    /// Field name (e.g., "Repo_id")
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// PostgreSQL table OID
    #[prost(int32, tag = "2")]
    pub table_id: i32,
    /// Column ID within table
    #[prost(int32, tag = "3")]
    pub column_id: i32,
    /// PostgreSQL data type OID
    #[prost(int32, tag = "4")]
    pub data_type_id: i32,
    /// Data type size (-1 for variable)
    #[prost(int32, tag = "5")]
    pub data_type_size: i32,
    /// Type-specific modifier
    #[prost(int32, tag = "6")]
    pub data_type_modifier: i32,
    /// "text" or "binary"
    #[prost(string, tag = "7")]
    pub format: ::prost::alloc::string::String,
    /// Additional field metadata
    ///
    /// Human-readable type name
    #[prost(string, tag = "8")]
    pub data_type_name: ::prost::alloc::string::String,
    /// Whether field can be null
    #[prost(bool, tag = "9")]
    pub nullable: bool,
    /// Whether field is part of primary key
    #[prost(bool, tag = "10")]
    pub primary_key: bool,
}
/// Query execution information
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryExecutionInfo {
    /// Timing breakdown
    ///
    /// Time to parse query
    #[prost(int64, tag = "1")]
    pub parse_time_ms: i64,
    /// Time to plan query
    #[prost(int64, tag = "2")]
    pub plan_time_ms: i64,
    /// Time to execute query
    #[prost(int64, tag = "3")]
    pub execute_time_ms: i64,
    /// Total query time
    #[prost(int64, tag = "4")]
    pub total_time_ms: i64,
    /// Execution statistics
    ///
    /// Rows examined by query
    #[prost(int64, tag = "5")]
    pub rows_examined: i64,
    /// Rows returned by query
    #[prost(int64, tag = "6")]
    pub rows_returned: i64,
    /// Bytes sent to client
    #[prost(int64, tag = "7")]
    pub bytes_sent: i64,
    /// Bytes received from server
    #[prost(int64, tag = "8")]
    pub bytes_received: i64,
    /// Query plan information (optional)
    ///
    /// EXPLAIN output (optional)
    #[prost(string, tag = "9")]
    pub execution_plan: ::prost::alloc::string::String,
    /// PostgreSQL notices/warnings
    #[prost(string, repeated, tag = "10")]
    pub notices: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// PostgreSQL-specific error information
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PostgreSqlError {
    /// SQL state code (e.g., "23505")
    #[prost(string, tag = "1")]
    pub sql_state: ::prost::alloc::string::String,
    /// Error message
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// Detailed error information
    #[prost(string, tag = "3")]
    pub detail: ::prost::alloc::string::String,
    /// Error hint
    #[prost(string, tag = "4")]
    pub hint: ::prost::alloc::string::String,
    /// Error position in query
    #[prost(string, tag = "5")]
    pub position: ::prost::alloc::string::String,
    /// Context where error occurred
    #[prost(string, tag = "6")]
    pub r#where: ::prost::alloc::string::String,
    /// Schema name (if applicable)
    #[prost(string, tag = "7")]
    pub schema_name: ::prost::alloc::string::String,
    /// Table name (if applicable)
    #[prost(string, tag = "8")]
    pub table_name: ::prost::alloc::string::String,
    /// Column name (if applicable)
    #[prost(string, tag = "9")]
    pub column_name: ::prost::alloc::string::String,
    /// Constraint name (if applicable)
    #[prost(string, tag = "10")]
    pub constraint_name: ::prost::alloc::string::String,
    /// Data type name (if applicable)
    #[prost(string, tag = "11")]
    pub data_type_name: ::prost::alloc::string::String,
    /// Source file where error occurred
    #[prost(string, tag = "12")]
    pub file: ::prost::alloc::string::String,
    /// Line number in source file
    #[prost(string, tag = "13")]
    pub line: ::prost::alloc::string::String,
    /// Routine name where error occurred
    #[prost(string, tag = "14")]
    pub routine: ::prost::alloc::string::String,
}
/// Prepared statement information
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PostgreSqlPreparedStatement {
    /// Name of prepared statement
    #[prost(string, tag = "1")]
    pub statement_name: ::prost::alloc::string::String,
    /// Original query text
    #[prost(string, tag = "2")]
    pub query_text: ::prost::alloc::string::String,
    /// Parameter type information
    #[prost(message, repeated, tag = "3")]
    pub parameter_types: ::prost::alloc::vec::Vec<PostgreSqlParameterType>,
    /// When statement was prepared
    #[prost(message, optional, tag = "4")]
    pub prepared_at: ::core::option::Option<::prost_types::Timestamp>,
    /// How many times executed
    #[prost(int32, tag = "5")]
    pub execution_count: i32,
}
/// Parameter type information for prepared statements
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PostgreSqlParameterType {
    /// Parameter position (1-based)
    #[prost(int32, tag = "1")]
    pub position: i32,
    /// PostgreSQL data type OID
    #[prost(int32, tag = "2")]
    pub data_type_id: i32,
    /// Human-readable type name
    #[prost(string, tag = "3")]
    pub data_type_name: ::prost::alloc::string::String,
    /// Whether parameter can be null
    #[prost(bool, tag = "4")]
    pub nullable: bool,
}
/// Transaction context
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PostgreSqlTransaction {
    /// Transaction identifier
    #[prost(string, tag = "1")]
    pub transaction_id: ::prost::alloc::string::String,
    /// Current transaction state
    #[prost(enumeration = "TransactionState", tag = "2")]
    pub state: i32,
    /// Transaction isolation level
    #[prost(enumeration = "IsolationLevel", tag = "3")]
    pub isolation_level: i32,
    /// Whether transaction is read-only
    #[prost(bool, tag = "4")]
    pub read_only: bool,
    /// When transaction started
    #[prost(message, optional, tag = "5")]
    pub started_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Batch query support
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PostgreSqlBatch {
    /// Queries in the batch
    #[prost(message, repeated, tag = "1")]
    pub queries: ::prost::alloc::vec::Vec<PostgreSqlQuery>,
    /// Whether to stop on first error
    #[prost(bool, tag = "2")]
    pub stop_on_error: bool,
    /// Whether to return individual results
    #[prost(bool, tag = "3")]
    pub return_results: bool,
}
/// Batch result
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PostgreSqlBatchResult {
    /// Results for each query
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<PostgreSqlResult>,
    /// Number of successful queries
    #[prost(int32, tag = "2")]
    pub successful_queries: i32,
    /// Number of failed queries
    #[prost(int32, tag = "3")]
    pub failed_queries: i32,
    /// First error encountered (if any)
    #[prost(message, optional, tag = "4")]
    pub first_error: ::core::option::Option<PostgreSqlError>,
}
/// Transaction state enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransactionState {
    Unspecified = 0,
    /// Not in a transaction
    Idle = 1,
    /// Transaction active
    Active = 2,
    /// Idle in transaction
    IdleInTransaction = 3,
    /// Idle in failed transaction
    IdleInFailedTransaction = 4,
}
impl TransactionState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TRANSACTION_STATE_UNSPECIFIED",
            Self::Idle => "TRANSACTION_STATE_IDLE",
            Self::Active => "TRANSACTION_STATE_ACTIVE",
            Self::IdleInTransaction => "TRANSACTION_STATE_IDLE_IN_TRANSACTION",
            Self::IdleInFailedTransaction => {
                "TRANSACTION_STATE_IDLE_IN_FAILED_TRANSACTION"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRANSACTION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "TRANSACTION_STATE_IDLE" => Some(Self::Idle),
            "TRANSACTION_STATE_ACTIVE" => Some(Self::Active),
            "TRANSACTION_STATE_IDLE_IN_TRANSACTION" => Some(Self::IdleInTransaction),
            "TRANSACTION_STATE_IDLE_IN_FAILED_TRANSACTION" => {
                Some(Self::IdleInFailedTransaction)
            }
            _ => None,
        }
    }
}
/// PostgreSQL isolation levels
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IsolationLevel {
    Unspecified = 0,
    ReadUncommitted = 1,
    ReadCommitted = 2,
    RepeatableRead = 3,
    Serializable = 4,
}
impl IsolationLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ISOLATION_LEVEL_UNSPECIFIED",
            Self::ReadUncommitted => "ISOLATION_LEVEL_READ_UNCOMMITTED",
            Self::ReadCommitted => "ISOLATION_LEVEL_READ_COMMITTED",
            Self::RepeatableRead => "ISOLATION_LEVEL_REPEATABLE_READ",
            Self::Serializable => "ISOLATION_LEVEL_SERIALIZABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ISOLATION_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
            "ISOLATION_LEVEL_READ_UNCOMMITTED" => Some(Self::ReadUncommitted),
            "ISOLATION_LEVEL_READ_COMMITTED" => Some(Self::ReadCommitted),
            "ISOLATION_LEVEL_REPEATABLE_READ" => Some(Self::RepeatableRead),
            "ISOLATION_LEVEL_SERIALIZABLE" => Some(Self::Serializable),
            _ => None,
        }
    }
}
