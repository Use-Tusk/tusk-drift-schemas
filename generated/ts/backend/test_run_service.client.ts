// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "backend/test_run_service.proto" (package "tusk.drift.backend.v1", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { TestRunService } from "./test_run_service";
import type { GetTraceTestsByIdsResponse } from "./test_run_service";
import type { GetTraceTestsByIdsRequest } from "./test_run_service";
import type { GetAllTraceTestIdsResponse } from "./test_run_service";
import type { GetAllTraceTestIdsRequest } from "./test_run_service";
import type { GetValidationTraceTestsResponse } from "./test_run_service";
import type { GetValidationTraceTestsRequest } from "./test_run_service";
import type { UpdateDriftRunCIStatusResponse } from "./test_run_service";
import type { UpdateDriftRunCIStatusRequest } from "./test_run_service";
import type { UploadTraceTestResultsResponse } from "./test_run_service";
import type { UploadTraceTestResultsRequest } from "./test_run_service";
import type { GetTraceTestResponse } from "./test_run_service";
import type { GetTraceTestRequest } from "./test_run_service";
import type { GetAllTraceTestsResponse } from "./test_run_service";
import type { GetAllTraceTestsRequest } from "./test_run_service";
import type { GetDriftRunTraceTestsResponse } from "./test_run_service";
import type { GetDriftRunTraceTestsRequest } from "./test_run_service";
import type { CreateDriftRunResponse } from "./test_run_service";
import type { CreateDriftRunRequest } from "./test_run_service";
import type { GetPreAppStartSpansResponse } from "./test_run_service";
import type { GetPreAppStartSpansRequest } from "./test_run_service";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { GetGlobalSpansResponse } from "./test_run_service";
import type { GetGlobalSpansRequest } from "./test_run_service";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * @generated from protobuf service tusk.drift.backend.v1.TestRunService
 */
export interface ITestRunServiceClient {
    /**
     * Get global spans - spans that can be used across all tests
     * e.g. outbound span to a jwks endpoint that may not be present in all traces
     * we're replaying
     *
     * @generated from protobuf rpc: GetGlobalSpans
     */
    getGlobalSpans(input: GetGlobalSpansRequest, options?: RpcOptions): UnaryCall<GetGlobalSpansRequest, GetGlobalSpansResponse>;
    /**
     * Get pre-app start spans - used to mock pre-app start spans
     *
     * @generated from protobuf rpc: GetPreAppStartSpans
     */
    getPreAppStartSpans(input: GetPreAppStartSpansRequest, options?: RpcOptions): UnaryCall<GetPreAppStartSpansRequest, GetPreAppStartSpansResponse>;
    /**
     * Create drift run in BE, also upserts commit and PR info
     *
     * @generated from protobuf rpc: CreateDriftRun
     */
    createDriftRun(input: CreateDriftRunRequest, options?: RpcOptions): UnaryCall<CreateDriftRunRequest, CreateDriftRunResponse>;
    /**
     * Get all trace tests for a drift run
     *
     * @generated from protobuf rpc: GetDriftRunTraceTests
     */
    getDriftRunTraceTests(input: GetDriftRunTraceTestsRequest, options?: RpcOptions): UnaryCall<GetDriftRunTraceTestsRequest, GetDriftRunTraceTestsResponse>;
    /**
     * Get all trace tests in test suite
     *
     * @generated from protobuf rpc: GetAllTraceTests
     */
    getAllTraceTests(input: GetAllTraceTestsRequest, options?: RpcOptions): UnaryCall<GetAllTraceTestsRequest, GetAllTraceTestsResponse>;
    /**
     * Get a single trace test
     *
     * @generated from protobuf rpc: GetTraceTest
     */
    getTraceTest(input: GetTraceTestRequest, options?: RpcOptions): UnaryCall<GetTraceTestRequest, GetTraceTestResponse>;
    /**
     * Upload trace test results to BE
     *
     * @generated from protobuf rpc: UploadTraceTestResults
     */
    uploadTraceTestResults(input: UploadTraceTestResultsRequest, options?: RpcOptions): UnaryCall<UploadTraceTestResultsRequest, UploadTraceTestResultsResponse>;
    /**
     * Allows CLI to indicate to backend that it's done running trace tests
     * This can also allow CLI to send a heartbeat to indicate it's still running
     *
     * @generated from protobuf rpc: UpdateDriftRunCIStatus
     */
    updateDriftRunCIStatus(input: UpdateDriftRunCIStatusRequest, options?: RpcOptions): UnaryCall<UpdateDriftRunCIStatusRequest, UpdateDriftRunCIStatusResponse>;
    // We were initially thinking we'd need GetDriftRunTestResults or
    // GetDriftRunTestStatus Since CI may wait for trace test results to be
    // uploaded and classified before exiting However, for now CI will just exit
    // with success if the tests were able to be run

    // Suite validation RPCs - used for validating traces on main branch

    /**
     * Get all traces for validation (both DRAFT and IN_SUITE)
     *
     * @generated from protobuf rpc: GetValidationTraceTests
     */
    getValidationTraceTests(input: GetValidationTraceTestsRequest, options?: RpcOptions): UnaryCall<GetValidationTraceTestsRequest, GetValidationTraceTestsResponse>;
    // Cache-friendly APIs for efficient trace syncing

    /**
     * Get all trace test IDs for a service (lightweight, no pagination needed)
     *
     * @generated from protobuf rpc: GetAllTraceTestIds
     */
    getAllTraceTestIds(input: GetAllTraceTestIdsRequest, options?: RpcOptions): UnaryCall<GetAllTraceTestIdsRequest, GetAllTraceTestIdsResponse>;
    /**
     * Get trace tests by their IDs (batch fetch)
     *
     * @generated from protobuf rpc: GetTraceTestsByIds
     */
    getTraceTestsByIds(input: GetTraceTestsByIdsRequest, options?: RpcOptions): UnaryCall<GetTraceTestsByIdsRequest, GetTraceTestsByIdsResponse>;
}
/**
 * @generated from protobuf service tusk.drift.backend.v1.TestRunService
 */
export class TestRunServiceClient implements ITestRunServiceClient, ServiceInfo {
    typeName = TestRunService.typeName;
    methods = TestRunService.methods;
    options = TestRunService.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Get global spans - spans that can be used across all tests
     * e.g. outbound span to a jwks endpoint that may not be present in all traces
     * we're replaying
     *
     * @generated from protobuf rpc: GetGlobalSpans
     */
    getGlobalSpans(input: GetGlobalSpansRequest, options?: RpcOptions): UnaryCall<GetGlobalSpansRequest, GetGlobalSpansResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetGlobalSpansRequest, GetGlobalSpansResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Get pre-app start spans - used to mock pre-app start spans
     *
     * @generated from protobuf rpc: GetPreAppStartSpans
     */
    getPreAppStartSpans(input: GetPreAppStartSpansRequest, options?: RpcOptions): UnaryCall<GetPreAppStartSpansRequest, GetPreAppStartSpansResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetPreAppStartSpansRequest, GetPreAppStartSpansResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Create drift run in BE, also upserts commit and PR info
     *
     * @generated from protobuf rpc: CreateDriftRun
     */
    createDriftRun(input: CreateDriftRunRequest, options?: RpcOptions): UnaryCall<CreateDriftRunRequest, CreateDriftRunResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<CreateDriftRunRequest, CreateDriftRunResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Get all trace tests for a drift run
     *
     * @generated from protobuf rpc: GetDriftRunTraceTests
     */
    getDriftRunTraceTests(input: GetDriftRunTraceTestsRequest, options?: RpcOptions): UnaryCall<GetDriftRunTraceTestsRequest, GetDriftRunTraceTestsResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetDriftRunTraceTestsRequest, GetDriftRunTraceTestsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Get all trace tests in test suite
     *
     * @generated from protobuf rpc: GetAllTraceTests
     */
    getAllTraceTests(input: GetAllTraceTestsRequest, options?: RpcOptions): UnaryCall<GetAllTraceTestsRequest, GetAllTraceTestsResponse> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetAllTraceTestsRequest, GetAllTraceTestsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Get a single trace test
     *
     * @generated from protobuf rpc: GetTraceTest
     */
    getTraceTest(input: GetTraceTestRequest, options?: RpcOptions): UnaryCall<GetTraceTestRequest, GetTraceTestResponse> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetTraceTestRequest, GetTraceTestResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Upload trace test results to BE
     *
     * @generated from protobuf rpc: UploadTraceTestResults
     */
    uploadTraceTestResults(input: UploadTraceTestResultsRequest, options?: RpcOptions): UnaryCall<UploadTraceTestResultsRequest, UploadTraceTestResultsResponse> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<UploadTraceTestResultsRequest, UploadTraceTestResultsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Allows CLI to indicate to backend that it's done running trace tests
     * This can also allow CLI to send a heartbeat to indicate it's still running
     *
     * @generated from protobuf rpc: UpdateDriftRunCIStatus
     */
    updateDriftRunCIStatus(input: UpdateDriftRunCIStatusRequest, options?: RpcOptions): UnaryCall<UpdateDriftRunCIStatusRequest, UpdateDriftRunCIStatusResponse> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept<UpdateDriftRunCIStatusRequest, UpdateDriftRunCIStatusResponse>("unary", this._transport, method, opt, input);
    }
    // We were initially thinking we'd need GetDriftRunTestResults or
    // GetDriftRunTestStatus Since CI may wait for trace test results to be
    // uploaded and classified before exiting However, for now CI will just exit
    // with success if the tests were able to be run

    // Suite validation RPCs - used for validating traces on main branch

    /**
     * Get all traces for validation (both DRAFT and IN_SUITE)
     *
     * @generated from protobuf rpc: GetValidationTraceTests
     */
    getValidationTraceTests(input: GetValidationTraceTestsRequest, options?: RpcOptions): UnaryCall<GetValidationTraceTestsRequest, GetValidationTraceTestsResponse> {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetValidationTraceTestsRequest, GetValidationTraceTestsResponse>("unary", this._transport, method, opt, input);
    }
    // Cache-friendly APIs for efficient trace syncing

    /**
     * Get all trace test IDs for a service (lightweight, no pagination needed)
     *
     * @generated from protobuf rpc: GetAllTraceTestIds
     */
    getAllTraceTestIds(input: GetAllTraceTestIdsRequest, options?: RpcOptions): UnaryCall<GetAllTraceTestIdsRequest, GetAllTraceTestIdsResponse> {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetAllTraceTestIdsRequest, GetAllTraceTestIdsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Get trace tests by their IDs (batch fetch)
     *
     * @generated from protobuf rpc: GetTraceTestsByIds
     */
    getTraceTestsByIds(input: GetTraceTestsByIdsRequest, options?: RpcOptions): UnaryCall<GetTraceTestsByIdsRequest, GetTraceTestsByIdsResponse> {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetTraceTestsByIdsRequest, GetTraceTestsByIdsResponse>("unary", this._transport, method, opt, input);
    }
}
