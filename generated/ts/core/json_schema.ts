// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "core/json_schema.proto" (package "tusk.drift.core.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Had to create this since proto3 doesn't support optional repeated fields
 *
 * @generated from protobuf message tusk.drift.core.v1.ItemTypesList
 */
export interface ItemTypesList {
    /**
     * @generated from protobuf field: repeated tusk.drift.core.v1.JsonSchemaType types = 1
     */
    types: JsonSchemaType[];
}
/**
 * Recursive JSON schema message
 * Describes the structure and metadata of JSON data
 *
 * @generated from protobuf message tusk.drift.core.v1.JsonSchema
 */
export interface JsonSchema {
    /**
     * The type of this schema node
     *
     * @generated from protobuf field: tusk.drift.core.v1.JsonSchemaType type = 1
     */
    type: JsonSchemaType;
    /**
     * For OBJECT types: map of property names to their schemas
     *
     * @generated from protobuf field: map<string, tusk.drift.core.v1.JsonSchema> properties = 2
     */
    properties: {
        [key: string]: JsonSchema;
    };
    /**
     * For ORDERED_LIST/UNORDERED_LIST types: schema of list items
     *
     * @generated from protobuf field: optional tusk.drift.core.v1.JsonSchema items = 3
     */
    items?: JsonSchema;
    /**
     * Optional encoding information (e.g., BASE64)
     *
     * @generated from protobuf field: optional tusk.drift.core.v1.EncodingType encoding = 4
     */
    encoding?: EncodingType;
    /**
     * Optional decoded content type (e.g., JSON, HTML)
     *
     * @generated from protobuf field: optional tusk.drift.core.v1.DecodedType decoded_type = 5
     */
    decodedType?: DecodedType;
    /**
     * Match importance for test matching (0.0 to 1.0)
     * 0.0 = lowest importance, 1.0 = highest importance
     *
     * @generated from protobuf field: optional double match_importance = 6
     */
    matchImportance?: number;
    /**
     * For mixed-type arrays: list of all types present in the array
     * Used when type is JSON_SCHEMA_TYPE_UNION to represent a union of types
     *
     * @generated from protobuf field: optional tusk.drift.core.v1.ItemTypesList item_types = 7
     */
    itemTypes?: ItemTypesList;
}
/**
 * JSON schema type enumeration
 * Language-agnostic type classification for JSON values
 *
 * @generated from protobuf enum tusk.drift.core.v1.JsonSchemaType
 */
export enum JsonSchemaType {
    /**
     * @generated from protobuf enum value: JSON_SCHEMA_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: JSON_SCHEMA_TYPE_NUMBER = 1;
     */
    NUMBER = 1,
    /**
     * @generated from protobuf enum value: JSON_SCHEMA_TYPE_STRING = 2;
     */
    STRING = 2,
    /**
     * @generated from protobuf enum value: JSON_SCHEMA_TYPE_BOOLEAN = 3;
     */
    BOOLEAN = 3,
    /**
     * @generated from protobuf enum value: JSON_SCHEMA_TYPE_NULL = 4;
     */
    NULL = 4,
    /**
     * @generated from protobuf enum value: JSON_SCHEMA_TYPE_UNDEFINED = 5;
     */
    UNDEFINED = 5,
    /**
     * @generated from protobuf enum value: JSON_SCHEMA_TYPE_OBJECT = 6;
     */
    OBJECT = 6,
    /**
     * @generated from protobuf enum value: JSON_SCHEMA_TYPE_ORDERED_LIST = 7;
     */
    ORDERED_LIST = 7,
    /**
     * @generated from protobuf enum value: JSON_SCHEMA_TYPE_UNORDERED_LIST = 8;
     */
    UNORDERED_LIST = 8,
    /**
     * @generated from protobuf enum value: JSON_SCHEMA_TYPE_FUNCTION = 9;
     */
    FUNCTION = 9,
    /**
     * @generated from protobuf enum value: JSON_SCHEMA_TYPE_UNION = 10;
     */
    UNION = 10
}
/**
 * Encoding type for data serialization
 *
 * @generated from protobuf enum tusk.drift.core.v1.EncodingType
 */
export enum EncodingType {
    /**
     * @generated from protobuf enum value: ENCODING_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: ENCODING_TYPE_BASE64 = 1;
     */
    BASE64 = 1
}
/**
 * Decoded content type classification
 * Describes the semantic type of decoded content
 *
 * @generated from protobuf enum tusk.drift.core.v1.DecodedType
 */
export enum DecodedType {
    /**
     * @generated from protobuf enum value: DECODED_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_JSON = 1;
     */
    JSON = 1,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_HTML = 2;
     */
    HTML = 2,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_CSS = 3;
     */
    CSS = 3,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_JAVASCRIPT = 4;
     */
    JAVASCRIPT = 4,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_XML = 5;
     */
    XML = 5,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_YAML = 6;
     */
    YAML = 6,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_MARKDOWN = 7;
     */
    MARKDOWN = 7,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_CSV = 8;
     */
    CSV = 8,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_SQL = 9;
     */
    SQL = 9,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_GRAPHQL = 10;
     */
    GRAPHQL = 10,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_PLAIN_TEXT = 11;
     */
    PLAIN_TEXT = 11,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_FORM_DATA = 12;
     */
    FORM_DATA = 12,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_MULTIPART_FORM = 13;
     */
    MULTIPART_FORM = 13,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_PDF = 14;
     */
    PDF = 14,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_AUDIO = 15;
     */
    AUDIO = 15,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_VIDEO = 16;
     */
    VIDEO = 16,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_GZIP = 17;
     */
    GZIP = 17,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_BINARY = 18;
     */
    BINARY = 18,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_JPEG = 19;
     */
    JPEG = 19,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_PNG = 20;
     */
    PNG = 20,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_GIF = 21;
     */
    GIF = 21,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_WEBP = 22;
     */
    WEBP = 22,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_SVG = 23;
     */
    SVG = 23,
    /**
     * @generated from protobuf enum value: DECODED_TYPE_ZIP = 24;
     */
    ZIP = 24
}
// @generated message type with reflection information, may provide speed optimized methods
class ItemTypesList$Type extends MessageType<ItemTypesList> {
    constructor() {
        super("tusk.drift.core.v1.ItemTypesList", [
            { no: 1, name: "types", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["tusk.drift.core.v1.JsonSchemaType", JsonSchemaType, "JSON_SCHEMA_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<ItemTypesList>): ItemTypesList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.types = [];
        if (value !== undefined)
            reflectionMergePartial<ItemTypesList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ItemTypesList): ItemTypesList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tusk.drift.core.v1.JsonSchemaType types */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.types.push(reader.int32());
                    else
                        message.types.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ItemTypesList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tusk.drift.core.v1.JsonSchemaType types = 1; */
        if (message.types.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.types.length; i++)
                writer.int32(message.types[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tusk.drift.core.v1.ItemTypesList
 */
export const ItemTypesList = new ItemTypesList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JsonSchema$Type extends MessageType<JsonSchema> {
    constructor() {
        super("tusk.drift.core.v1.JsonSchema", [
            { no: 1, name: "type", kind: "enum", T: () => ["tusk.drift.core.v1.JsonSchemaType", JsonSchemaType, "JSON_SCHEMA_TYPE_"] },
            { no: 2, name: "properties", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => JsonSchema } },
            { no: 3, name: "items", kind: "message", T: () => JsonSchema },
            { no: 4, name: "encoding", kind: "enum", opt: true, T: () => ["tusk.drift.core.v1.EncodingType", EncodingType, "ENCODING_TYPE_"] },
            { no: 5, name: "decoded_type", kind: "enum", opt: true, T: () => ["tusk.drift.core.v1.DecodedType", DecodedType, "DECODED_TYPE_"] },
            { no: 6, name: "match_importance", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "item_types", kind: "message", T: () => ItemTypesList }
        ]);
    }
    create(value?: PartialMessage<JsonSchema>): JsonSchema {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.properties = {};
        if (value !== undefined)
            reflectionMergePartial<JsonSchema>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JsonSchema): JsonSchema {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tusk.drift.core.v1.JsonSchemaType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* map<string, tusk.drift.core.v1.JsonSchema> properties */ 2:
                    this.binaryReadMap2(message.properties, reader, options);
                    break;
                case /* optional tusk.drift.core.v1.JsonSchema items */ 3:
                    message.items = JsonSchema.internalBinaryRead(reader, reader.uint32(), options, message.items);
                    break;
                case /* optional tusk.drift.core.v1.EncodingType encoding */ 4:
                    message.encoding = reader.int32();
                    break;
                case /* optional tusk.drift.core.v1.DecodedType decoded_type */ 5:
                    message.decodedType = reader.int32();
                    break;
                case /* optional double match_importance */ 6:
                    message.matchImportance = reader.double();
                    break;
                case /* optional tusk.drift.core.v1.ItemTypesList item_types */ 7:
                    message.itemTypes = ItemTypesList.internalBinaryRead(reader, reader.uint32(), options, message.itemTypes);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: JsonSchema["properties"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof JsonSchema["properties"] | undefined, val: JsonSchema["properties"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = JsonSchema.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for tusk.drift.core.v1.JsonSchema.properties");
            }
        }
        map[key ?? ""] = val ?? JsonSchema.create();
    }
    internalBinaryWrite(message: JsonSchema, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tusk.drift.core.v1.JsonSchemaType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* map<string, tusk.drift.core.v1.JsonSchema> properties = 2; */
        for (let k of globalThis.Object.keys(message.properties)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            JsonSchema.internalBinaryWrite(message.properties[k], writer, options);
            writer.join().join();
        }
        /* optional tusk.drift.core.v1.JsonSchema items = 3; */
        if (message.items)
            JsonSchema.internalBinaryWrite(message.items, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional tusk.drift.core.v1.EncodingType encoding = 4; */
        if (message.encoding !== undefined)
            writer.tag(4, WireType.Varint).int32(message.encoding);
        /* optional tusk.drift.core.v1.DecodedType decoded_type = 5; */
        if (message.decodedType !== undefined)
            writer.tag(5, WireType.Varint).int32(message.decodedType);
        /* optional double match_importance = 6; */
        if (message.matchImportance !== undefined)
            writer.tag(6, WireType.Bit64).double(message.matchImportance);
        /* optional tusk.drift.core.v1.ItemTypesList item_types = 7; */
        if (message.itemTypes)
            ItemTypesList.internalBinaryWrite(message.itemTypes, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tusk.drift.core.v1.JsonSchema
 */
export const JsonSchema = new JsonSchema$Type();
