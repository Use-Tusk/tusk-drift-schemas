// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "core/span.proto" (package "tusk.drift.core.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Value } from "../google/protobuf/struct";
import { Duration } from "../google/protobuf/duration";
import { Timestamp } from "../google/protobuf/timestamp";
import { JsonSchema } from "./json_schema";
import { Struct } from "../google/protobuf/struct";
/**
 * Universal span structure that works for all instrumentation types
 *
 * @generated from protobuf message tusk.drift.core.v1.Span
 */
export interface Span {
    /**
     * Core span identity
     *
     * @generated from protobuf field: string trace_id = 1
     */
    traceId: string;
    /**
     * @generated from protobuf field: string span_id = 2
     */
    spanId: string;
    /**
     * @generated from protobuf field: string parent_span_id = 3
     */
    parentSpanId: string;
    /**
     * Visual name
     *
     * @generated from protobuf field: string name = 4
     */
    name: string; // "api/process_commit", "update UserQuery", "pg.query"
    /**
     * Instrumentation identity
     *
     * @generated from protobuf field: string package_name = 5
     */
    packageName: string; // "http", "pg", "mysql", "redis", "fetch"
    /**
     * @generated from protobuf field: string instrumentation_name = 6
     */
    instrumentationName: string; // instrumentation class name
    /**
     * @generated from protobuf field: string submodule_name = 7
     */
    submoduleName: string; // "GET", "query", "execute", "get", etc.
    /**
     * Package type classification
     *
     * @generated from protobuf field: tusk.drift.core.v1.PackageType package_type = 8
     */
    packageType: PackageType; // Enum classification of package type
    /**
     * Input/output data
     *
     * @generated from protobuf field: google.protobuf.Struct input_value = 9
     */
    inputValue?: Struct; // Request/query/command data
    /**
     * @generated from protobuf field: google.protobuf.Struct output_value = 10
     */
    outputValue?: Struct; // Response/result data
    /**
     * @generated from protobuf field: tusk.drift.core.v1.JsonSchema input_schema = 11
     */
    inputSchema?: JsonSchema; // Schema definition for input
    /**
     * @generated from protobuf field: tusk.drift.core.v1.JsonSchema output_schema = 12
     */
    outputSchema?: JsonSchema; // Schema definition for output
    /**
     * Hash-based matching and validation
     *
     * @generated from protobuf field: string input_schema_hash = 13
     */
    inputSchemaHash: string; // Hash of input schema for validation
    /**
     * @generated from protobuf field: string output_schema_hash = 14
     */
    outputSchemaHash: string; // Hash of output schema for validation
    /**
     * @generated from protobuf field: string input_value_hash = 15
     */
    inputValueHash: string; // Hash of input_value for matching
    /**
     * @generated from protobuf field: string output_value_hash = 16
     */
    outputValueHash: string; // Hash of output_value
    /**
     * Span metadata
     *
     * @generated from protobuf field: tusk.drift.core.v1.SpanKind kind = 17
     */
    kind: SpanKind; // OpenTelemetry-compatible span kind
    /**
     * @generated from protobuf field: tusk.drift.core.v1.SpanStatus status = 18
     */
    status?: SpanStatus; // Span completion status
    /**
     * @generated from protobuf field: bool is_pre_app_start = 19
     */
    isPreAppStart: boolean; // Whether the span is a before user marking app as ready
    /**
     * Timing information
     *
     * @generated from protobuf field: google.protobuf.Timestamp timestamp = 20
     */
    timestamp?: Timestamp; // Primary timestamp
    /**
     * @generated from protobuf field: google.protobuf.Duration duration = 21
     */
    duration?: Duration; // Primary duration
    /**
     * Span relationships and state
     *
     * @generated from protobuf field: bool is_root_span = 22
     */
    isRootSpan: boolean;
    /**
     * @generated from protobuf field: google.protobuf.Struct metadata = 23
     */
    metadata?: Struct; // Additional metadata
}
/**
 * Span completion status
 *
 * @generated from protobuf message tusk.drift.core.v1.SpanStatus
 */
export interface SpanStatus {
    /**
     * @generated from protobuf field: tusk.drift.core.v1.StatusCode code = 1
     */
    code: StatusCode;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * Span events (logs) - optional
 *
 * @generated from protobuf message tusk.drift.core.v1.SpanEvent
 */
export interface SpanEvent {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp timestamp = 2
     */
    timestamp?: Timestamp;
    /**
     * @generated from protobuf field: map<string, google.protobuf.Value> attributes = 3
     */
    attributes: {
        [key: string]: Value;
    };
}
/**
 * Span links - optional
 *
 * @generated from protobuf message tusk.drift.core.v1.SpanLink
 */
export interface SpanLink {
    /**
     * @generated from protobuf field: string trace_id = 1
     */
    traceId: string;
    /**
     * @generated from protobuf field: string span_id = 2
     */
    spanId: string;
    /**
     * @generated from protobuf field: map<string, google.protobuf.Value> attributes = 3
     */
    attributes: {
        [key: string]: Value;
    };
}
/**
 * Trace collection
 *
 * @generated from protobuf message tusk.drift.core.v1.Trace
 */
export interface Trace {
    /**
     * @generated from protobuf field: string trace_id = 1
     */
    traceId: string;
    /**
     * @generated from protobuf field: repeated tusk.drift.core.v1.Span spans = 2
     */
    spans: Span[];
    /**
     * @generated from protobuf field: google.protobuf.Timestamp started_at = 3
     */
    startedAt?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp completed_at = 4
     */
    completedAt?: Timestamp;
    /**
     * @generated from protobuf field: map<string, string> metadata = 5
     */
    metadata: {
        [key: string]: string;
    }; // Trace-level metadata
}
/**
 * Package type classification enum
 * Langauge agnostic
 *
 * @generated from protobuf enum tusk.drift.core.v1.PackageType
 */
export enum PackageType {
    /**
     * @generated from protobuf enum value: PACKAGE_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * HTTP-based operations
     *
     * @generated from protobuf enum value: PACKAGE_TYPE_HTTP = 1;
     */
    HTTP = 1,
    /**
     * GraphQL operations
     *
     * @generated from protobuf enum value: PACKAGE_TYPE_GRAPHQL = 2;
     */
    GRAPHQL = 2,
    /**
     * gRPC operations
     *
     * @generated from protobuf enum value: PACKAGE_TYPE_GRPC = 3;
     */
    GRPC = 3,
    /**
     * PostgreSQL operations
     *
     * @generated from protobuf enum value: PACKAGE_TYPE_PG = 4;
     */
    PG = 4,
    /**
     * MySQL operations
     *
     * @generated from protobuf enum value: PACKAGE_TYPE_MYSQL = 5;
     */
    MYSQL = 5,
    /**
     * MongoDB operations
     *
     * @generated from protobuf enum value: PACKAGE_TYPE_MONGODB = 6;
     */
    MONGODB = 6,
    /**
     * Redis caching operations
     *
     * @generated from protobuf enum value: PACKAGE_TYPE_REDIS = 7;
     */
    REDIS = 7,
    /**
     * Apache Kafka messaging
     *
     * @generated from protobuf enum value: PACKAGE_TYPE_KAFKA = 8;
     */
    KAFKA = 8,
    /**
     * RabbitMQ messaging
     *
     * @generated from protobuf enum value: PACKAGE_TYPE_RABBITMQ = 9;
     */
    RABBITMQ = 9
}
/**
 * OpenTelemetry-compatible span kinds
 *
 * @generated from protobuf enum tusk.drift.core.v1.SpanKind
 */
export enum SpanKind {
    /**
     * @generated from protobuf enum value: SPAN_KIND_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Internal operation
     *
     * @generated from protobuf enum value: SPAN_KIND_INTERNAL = 1;
     */
    INTERNAL = 1,
    /**
     * Server-side operation
     *
     * @generated from protobuf enum value: SPAN_KIND_SERVER = 2;
     */
    SERVER = 2,
    /**
     * Client-side operation
     *
     * @generated from protobuf enum value: SPAN_KIND_CLIENT = 3;
     */
    CLIENT = 3,
    /**
     * Message producer
     *
     * @generated from protobuf enum value: SPAN_KIND_PRODUCER = 4;
     */
    PRODUCER = 4,
    /**
     * Message consumer
     *
     * @generated from protobuf enum value: SPAN_KIND_CONSUMER = 5;
     */
    CONSUMER = 5
}
/**
 * @generated from protobuf enum tusk.drift.core.v1.StatusCode
 */
export enum StatusCode {
    /**
     * Default state
     *
     * @generated from protobuf enum value: STATUS_CODE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Success
     *
     * @generated from protobuf enum value: STATUS_CODE_OK = 1;
     */
    OK = 1,
    /**
     * Error occurred
     *
     * @generated from protobuf enum value: STATUS_CODE_ERROR = 2;
     */
    ERROR = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Span$Type extends MessageType<Span> {
    constructor() {
        super("tusk.drift.core.v1.Span", [
            { no: 1, name: "trace_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "span_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "parent_span_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "package_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "instrumentation_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "submodule_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "package_type", kind: "enum", T: () => ["tusk.drift.core.v1.PackageType", PackageType, "PACKAGE_TYPE_"] },
            { no: 9, name: "input_value", kind: "message", T: () => Struct },
            { no: 10, name: "output_value", kind: "message", T: () => Struct },
            { no: 11, name: "input_schema", kind: "message", T: () => JsonSchema },
            { no: 12, name: "output_schema", kind: "message", T: () => JsonSchema },
            { no: 13, name: "input_schema_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "output_schema_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "input_value_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "output_value_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "kind", kind: "enum", T: () => ["tusk.drift.core.v1.SpanKind", SpanKind, "SPAN_KIND_"] },
            { no: 18, name: "status", kind: "message", T: () => SpanStatus },
            { no: 19, name: "is_pre_app_start", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 20, name: "timestamp", kind: "message", T: () => Timestamp },
            { no: 21, name: "duration", kind: "message", T: () => Duration },
            { no: 22, name: "is_root_span", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 23, name: "metadata", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<Span>): Span {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.traceId = "";
        message.spanId = "";
        message.parentSpanId = "";
        message.name = "";
        message.packageName = "";
        message.instrumentationName = "";
        message.submoduleName = "";
        message.packageType = 0;
        message.inputSchemaHash = "";
        message.outputSchemaHash = "";
        message.inputValueHash = "";
        message.outputValueHash = "";
        message.kind = 0;
        message.isPreAppStart = false;
        message.isRootSpan = false;
        if (value !== undefined)
            reflectionMergePartial<Span>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Span): Span {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string trace_id */ 1:
                    message.traceId = reader.string();
                    break;
                case /* string span_id */ 2:
                    message.spanId = reader.string();
                    break;
                case /* string parent_span_id */ 3:
                    message.parentSpanId = reader.string();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                case /* string package_name */ 5:
                    message.packageName = reader.string();
                    break;
                case /* string instrumentation_name */ 6:
                    message.instrumentationName = reader.string();
                    break;
                case /* string submodule_name */ 7:
                    message.submoduleName = reader.string();
                    break;
                case /* tusk.drift.core.v1.PackageType package_type */ 8:
                    message.packageType = reader.int32();
                    break;
                case /* google.protobuf.Struct input_value */ 9:
                    message.inputValue = Struct.internalBinaryRead(reader, reader.uint32(), options, message.inputValue);
                    break;
                case /* google.protobuf.Struct output_value */ 10:
                    message.outputValue = Struct.internalBinaryRead(reader, reader.uint32(), options, message.outputValue);
                    break;
                case /* tusk.drift.core.v1.JsonSchema input_schema */ 11:
                    message.inputSchema = JsonSchema.internalBinaryRead(reader, reader.uint32(), options, message.inputSchema);
                    break;
                case /* tusk.drift.core.v1.JsonSchema output_schema */ 12:
                    message.outputSchema = JsonSchema.internalBinaryRead(reader, reader.uint32(), options, message.outputSchema);
                    break;
                case /* string input_schema_hash */ 13:
                    message.inputSchemaHash = reader.string();
                    break;
                case /* string output_schema_hash */ 14:
                    message.outputSchemaHash = reader.string();
                    break;
                case /* string input_value_hash */ 15:
                    message.inputValueHash = reader.string();
                    break;
                case /* string output_value_hash */ 16:
                    message.outputValueHash = reader.string();
                    break;
                case /* tusk.drift.core.v1.SpanKind kind */ 17:
                    message.kind = reader.int32();
                    break;
                case /* tusk.drift.core.v1.SpanStatus status */ 18:
                    message.status = SpanStatus.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* bool is_pre_app_start */ 19:
                    message.isPreAppStart = reader.bool();
                    break;
                case /* google.protobuf.Timestamp timestamp */ 20:
                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                case /* google.protobuf.Duration duration */ 21:
                    message.duration = Duration.internalBinaryRead(reader, reader.uint32(), options, message.duration);
                    break;
                case /* bool is_root_span */ 22:
                    message.isRootSpan = reader.bool();
                    break;
                case /* google.protobuf.Struct metadata */ 23:
                    message.metadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Span, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string trace_id = 1; */
        if (message.traceId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.traceId);
        /* string span_id = 2; */
        if (message.spanId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.spanId);
        /* string parent_span_id = 3; */
        if (message.parentSpanId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.parentSpanId);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        /* string package_name = 5; */
        if (message.packageName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.packageName);
        /* string instrumentation_name = 6; */
        if (message.instrumentationName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.instrumentationName);
        /* string submodule_name = 7; */
        if (message.submoduleName !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.submoduleName);
        /* tusk.drift.core.v1.PackageType package_type = 8; */
        if (message.packageType !== 0)
            writer.tag(8, WireType.Varint).int32(message.packageType);
        /* google.protobuf.Struct input_value = 9; */
        if (message.inputValue)
            Struct.internalBinaryWrite(message.inputValue, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct output_value = 10; */
        if (message.outputValue)
            Struct.internalBinaryWrite(message.outputValue, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* tusk.drift.core.v1.JsonSchema input_schema = 11; */
        if (message.inputSchema)
            JsonSchema.internalBinaryWrite(message.inputSchema, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* tusk.drift.core.v1.JsonSchema output_schema = 12; */
        if (message.outputSchema)
            JsonSchema.internalBinaryWrite(message.outputSchema, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* string input_schema_hash = 13; */
        if (message.inputSchemaHash !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.inputSchemaHash);
        /* string output_schema_hash = 14; */
        if (message.outputSchemaHash !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.outputSchemaHash);
        /* string input_value_hash = 15; */
        if (message.inputValueHash !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.inputValueHash);
        /* string output_value_hash = 16; */
        if (message.outputValueHash !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.outputValueHash);
        /* tusk.drift.core.v1.SpanKind kind = 17; */
        if (message.kind !== 0)
            writer.tag(17, WireType.Varint).int32(message.kind);
        /* tusk.drift.core.v1.SpanStatus status = 18; */
        if (message.status)
            SpanStatus.internalBinaryWrite(message.status, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* bool is_pre_app_start = 19; */
        if (message.isPreAppStart !== false)
            writer.tag(19, WireType.Varint).bool(message.isPreAppStart);
        /* google.protobuf.Timestamp timestamp = 20; */
        if (message.timestamp)
            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration duration = 21; */
        if (message.duration)
            Duration.internalBinaryWrite(message.duration, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* bool is_root_span = 22; */
        if (message.isRootSpan !== false)
            writer.tag(22, WireType.Varint).bool(message.isRootSpan);
        /* google.protobuf.Struct metadata = 23; */
        if (message.metadata)
            Struct.internalBinaryWrite(message.metadata, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tusk.drift.core.v1.Span
 */
export const Span = new Span$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpanStatus$Type extends MessageType<SpanStatus> {
    constructor() {
        super("tusk.drift.core.v1.SpanStatus", [
            { no: 1, name: "code", kind: "enum", T: () => ["tusk.drift.core.v1.StatusCode", StatusCode, "STATUS_CODE_"] },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SpanStatus>): SpanStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = 0;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<SpanStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpanStatus): SpanStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tusk.drift.core.v1.StatusCode code */ 1:
                    message.code = reader.int32();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpanStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tusk.drift.core.v1.StatusCode code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tusk.drift.core.v1.SpanStatus
 */
export const SpanStatus = new SpanStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpanEvent$Type extends MessageType<SpanEvent> {
    constructor() {
        super("tusk.drift.core.v1.SpanEvent", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "timestamp", kind: "message", T: () => Timestamp },
            { no: 3, name: "attributes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Value } }
        ]);
    }
    create(value?: PartialMessage<SpanEvent>): SpanEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.attributes = {};
        if (value !== undefined)
            reflectionMergePartial<SpanEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpanEvent): SpanEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Timestamp timestamp */ 2:
                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                case /* map<string, google.protobuf.Value> attributes */ 3:
                    this.binaryReadMap3(message.attributes, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: SpanEvent["attributes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SpanEvent["attributes"] | undefined, val: SpanEvent["attributes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Value.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for tusk.drift.core.v1.SpanEvent.attributes");
            }
        }
        map[key ?? ""] = val ?? Value.create();
    }
    internalBinaryWrite(message: SpanEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Timestamp timestamp = 2; */
        if (message.timestamp)
            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* map<string, google.protobuf.Value> attributes = 3; */
        for (let k of globalThis.Object.keys(message.attributes)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Value.internalBinaryWrite(message.attributes[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tusk.drift.core.v1.SpanEvent
 */
export const SpanEvent = new SpanEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpanLink$Type extends MessageType<SpanLink> {
    constructor() {
        super("tusk.drift.core.v1.SpanLink", [
            { no: 1, name: "trace_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "span_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "attributes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Value } }
        ]);
    }
    create(value?: PartialMessage<SpanLink>): SpanLink {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.traceId = "";
        message.spanId = "";
        message.attributes = {};
        if (value !== undefined)
            reflectionMergePartial<SpanLink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpanLink): SpanLink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string trace_id */ 1:
                    message.traceId = reader.string();
                    break;
                case /* string span_id */ 2:
                    message.spanId = reader.string();
                    break;
                case /* map<string, google.protobuf.Value> attributes */ 3:
                    this.binaryReadMap3(message.attributes, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: SpanLink["attributes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SpanLink["attributes"] | undefined, val: SpanLink["attributes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Value.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for tusk.drift.core.v1.SpanLink.attributes");
            }
        }
        map[key ?? ""] = val ?? Value.create();
    }
    internalBinaryWrite(message: SpanLink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string trace_id = 1; */
        if (message.traceId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.traceId);
        /* string span_id = 2; */
        if (message.spanId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.spanId);
        /* map<string, google.protobuf.Value> attributes = 3; */
        for (let k of globalThis.Object.keys(message.attributes)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Value.internalBinaryWrite(message.attributes[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tusk.drift.core.v1.SpanLink
 */
export const SpanLink = new SpanLink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Trace$Type extends MessageType<Trace> {
    constructor() {
        super("tusk.drift.core.v1.Trace", [
            { no: 1, name: "trace_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "spans", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Span },
            { no: 3, name: "started_at", kind: "message", T: () => Timestamp },
            { no: 4, name: "completed_at", kind: "message", T: () => Timestamp },
            { no: 5, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<Trace>): Trace {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.traceId = "";
        message.spans = [];
        message.metadata = {};
        if (value !== undefined)
            reflectionMergePartial<Trace>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Trace): Trace {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string trace_id */ 1:
                    message.traceId = reader.string();
                    break;
                case /* repeated tusk.drift.core.v1.Span spans */ 2:
                    message.spans.push(Span.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Timestamp started_at */ 3:
                    message.startedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startedAt);
                    break;
                case /* google.protobuf.Timestamp completed_at */ 4:
                    message.completedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.completedAt);
                    break;
                case /* map<string, string> metadata */ 5:
                    this.binaryReadMap5(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: Trace["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Trace["metadata"] | undefined, val: Trace["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for tusk.drift.core.v1.Trace.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Trace, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string trace_id = 1; */
        if (message.traceId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.traceId);
        /* repeated tusk.drift.core.v1.Span spans = 2; */
        for (let i = 0; i < message.spans.length; i++)
            Span.internalBinaryWrite(message.spans[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp started_at = 3; */
        if (message.startedAt)
            Timestamp.internalBinaryWrite(message.startedAt, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp completed_at = 4; */
        if (message.completedAt)
            Timestamp.internalBinaryWrite(message.completedAt, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> metadata = 5; */
        for (let k of globalThis.Object.keys(message.metadata))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tusk.drift.core.v1.Trace
 */
export const Trace = new Trace$Type();
