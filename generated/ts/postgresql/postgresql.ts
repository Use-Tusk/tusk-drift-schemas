// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "postgresql/postgresql.proto" (package "tusk.drift.instrumentation.postgresql.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../google/protobuf/timestamp";
import { Struct } from "../google/protobuf/struct";
/**
 * PostgreSQL query request - used internally by PostgreSQL instrumentation SDK
 *
 * @generated from protobuf message tusk.drift.instrumentation.postgresql.v1.PostgreSQLQuery
 */
export interface PostgreSQLQuery {
    /**
     * Core query information
     *
     * @generated from protobuf field: string text = 1
     */
    text: string; // SQL query text
    /**
     * @generated from protobuf field: repeated string values = 2
     */
    values: string[]; // Parameterized query values (always strings)
    /**
     * @generated from protobuf field: string client_type = 3
     */
    clientType: string; // "client", "pool", etc.
    /**
     * Connection context
     *
     * @generated from protobuf field: tusk.drift.instrumentation.postgresql.v1.PostgreSQLConnection connection = 4
     */
    connection?: PostgreSQLConnection; // Connection information
    /**
     * @generated from protobuf field: tusk.drift.instrumentation.postgresql.v1.QueryOptions options = 5
     */
    options?: QueryOptions; // Query execution options
    /**
     * Query metadata
     *
     * @generated from protobuf field: string query_id = 6
     */
    queryId: string; // Unique query identifier (optional)
    /**
     * @generated from protobuf field: map<string, string> tags = 7
     */
    tags: {
        [key: string]: string;
    }; // Custom tags for the query
}
/**
 * PostgreSQL connection information
 *
 * @generated from protobuf message tusk.drift.instrumentation.postgresql.v1.PostgreSQLConnection
 */
export interface PostgreSQLConnection {
    /**
     * @generated from protobuf field: string database_name = 1
     */
    databaseName: string; // Database name
    /**
     * @generated from protobuf field: string username = 2
     */
    username: string; // Username (without password)
    /**
     * @generated from protobuf field: string host = 3
     */
    host: string; // Host address
    /**
     * @generated from protobuf field: int32 port = 4
     */
    port: number; // Port number
    /**
     * @generated from protobuf field: string application_name = 5
     */
    applicationName: string; // Application name in connection
    /**
     * @generated from protobuf field: string connection_id = 6
     */
    connectionId: string; // Connection identifier
    /**
     * @generated from protobuf field: bool ssl_enabled = 7
     */
    sslEnabled: boolean; // Whether SSL is enabled
    /**
     * @generated from protobuf field: string server_version = 8
     */
    serverVersion: string; // PostgreSQL server version
}
/**
 * Query execution options
 *
 * @generated from protobuf message tusk.drift.instrumentation.postgresql.v1.QueryOptions
 */
export interface QueryOptions {
    /**
     * @generated from protobuf field: int32 statement_timeout = 1
     */
    statementTimeout: number; // Statement timeout in milliseconds
    /**
     * @generated from protobuf field: int32 query_timeout = 2
     */
    queryTimeout: number; // Query timeout in milliseconds
    /**
     * @generated from protobuf field: bool binary_mode = 3
     */
    binaryMode: boolean; // Whether binary mode is enabled
    /**
     * @generated from protobuf field: string cursor_name = 4
     */
    cursorName: string; // Cursor name (for cursor queries)
    /**
     * @generated from protobuf field: int32 fetch_size = 5
     */
    fetchSize: number; // Fetch size for large result sets
    /**
     * @generated from protobuf field: bool read_only = 6
     */
    readOnly: boolean; // Whether query is read-only
    /**
     * @generated from protobuf field: map<string, string> custom_options = 7
     */
    customOptions: {
        [key: string]: string;
    }; // Custom driver options
}
/**
 * PostgreSQL query result - matches your trace data structure
 *
 * @generated from protobuf message tusk.drift.instrumentation.postgresql.v1.PostgreSQLResult
 */
export interface PostgreSQLResult {
    /**
     * Core result information (from your trace data)
     *
     * @generated from protobuf field: string command = 1
     */
    command: string; // "SELECT", "INSERT", "UPDATE", etc.
    /**
     * @generated from protobuf field: int32 row_count = 2
     */
    rowCount: number; // Number of rows affected/returned
    /**
     * @generated from protobuf field: optional int32 oid = 3
     */
    oid?: number; // Object ID (PostgreSQL-specific, can be null)
    /**
     * Result data
     *
     * @generated from protobuf field: repeated google.protobuf.Struct rows = 4
     */
    rows: Struct[]; // Actual row data as JSON objects
    /**
     * @generated from protobuf field: repeated tusk.drift.instrumentation.postgresql.v1.PostgreSQLField fields = 5
     */
    fields: PostgreSQLField[]; // Field/column definitions
    /**
     * Query execution metadata
     *
     * @generated from protobuf field: tusk.drift.instrumentation.postgresql.v1.QueryExecutionInfo execution_info = 6
     */
    executionInfo?: QueryExecutionInfo; // Execution details
    /**
     * Error information (if query failed)
     *
     * @generated from protobuf field: optional tusk.drift.instrumentation.postgresql.v1.PostgreSQLError error = 7
     */
    error?: PostgreSQLError; // Error details
}
/**
 * PostgreSQL field definition (matches your trace data)
 *
 * @generated from protobuf message tusk.drift.instrumentation.postgresql.v1.PostgreSQLField
 */
export interface PostgreSQLField {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string; // Field name (e.g., "Repo_id")
    /**
     * @generated from protobuf field: int32 table_id = 2
     */
    tableId: number; // PostgreSQL table OID
    /**
     * @generated from protobuf field: int32 column_id = 3
     */
    columnId: number; // Column ID within table
    /**
     * @generated from protobuf field: int32 data_type_id = 4
     */
    dataTypeId: number; // PostgreSQL data type OID
    /**
     * @generated from protobuf field: int32 data_type_size = 5
     */
    dataTypeSize: number; // Data type size (-1 for variable)
    /**
     * @generated from protobuf field: int32 data_type_modifier = 6
     */
    dataTypeModifier: number; // Type-specific modifier
    /**
     * @generated from protobuf field: string format = 7
     */
    format: string; // "text" or "binary"
    /**
     * Additional field metadata
     *
     * @generated from protobuf field: string data_type_name = 8
     */
    dataTypeName: string; // Human-readable type name
    /**
     * @generated from protobuf field: bool nullable = 9
     */
    nullable: boolean; // Whether field can be null
    /**
     * @generated from protobuf field: bool primary_key = 10
     */
    primaryKey: boolean; // Whether field is part of primary key
}
/**
 * Query execution information
 *
 * @generated from protobuf message tusk.drift.instrumentation.postgresql.v1.QueryExecutionInfo
 */
export interface QueryExecutionInfo {
    /**
     * Timing breakdown
     *
     * @generated from protobuf field: int64 parse_time_ms = 1
     */
    parseTimeMs: bigint; // Time to parse query
    /**
     * @generated from protobuf field: int64 plan_time_ms = 2
     */
    planTimeMs: bigint; // Time to plan query
    /**
     * @generated from protobuf field: int64 execute_time_ms = 3
     */
    executeTimeMs: bigint; // Time to execute query
    /**
     * @generated from protobuf field: int64 total_time_ms = 4
     */
    totalTimeMs: bigint; // Total query time
    /**
     * Execution statistics
     *
     * @generated from protobuf field: int64 rows_examined = 5
     */
    rowsExamined: bigint; // Rows examined by query
    /**
     * @generated from protobuf field: int64 rows_returned = 6
     */
    rowsReturned: bigint; // Rows returned by query
    /**
     * @generated from protobuf field: int64 bytes_sent = 7
     */
    bytesSent: bigint; // Bytes sent to client
    /**
     * @generated from protobuf field: int64 bytes_received = 8
     */
    bytesReceived: bigint; // Bytes received from server
    /**
     * Query plan information (optional)
     *
     * @generated from protobuf field: string execution_plan = 9
     */
    executionPlan: string; // EXPLAIN output (optional)
    /**
     * @generated from protobuf field: repeated string notices = 10
     */
    notices: string[]; // PostgreSQL notices/warnings
}
/**
 * PostgreSQL-specific error information
 *
 * @generated from protobuf message tusk.drift.instrumentation.postgresql.v1.PostgreSQLError
 */
export interface PostgreSQLError {
    /**
     * @generated from protobuf field: string sql_state = 1
     */
    sqlState: string; // SQL state code (e.g., "23505")
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string; // Error message
    /**
     * @generated from protobuf field: string detail = 3
     */
    detail: string; // Detailed error information
    /**
     * @generated from protobuf field: string hint = 4
     */
    hint: string; // Error hint
    /**
     * @generated from protobuf field: string position = 5
     */
    position: string; // Error position in query
    /**
     * @generated from protobuf field: string where = 6
     */
    where: string; // Context where error occurred
    /**
     * @generated from protobuf field: string schema_name = 7
     */
    schemaName: string; // Schema name (if applicable)
    /**
     * @generated from protobuf field: string table_name = 8
     */
    tableName: string; // Table name (if applicable)
    /**
     * @generated from protobuf field: string column_name = 9
     */
    columnName: string; // Column name (if applicable)
    /**
     * @generated from protobuf field: string constraint_name = 10
     */
    constraintName: string; // Constraint name (if applicable)
    /**
     * @generated from protobuf field: string data_type_name = 11
     */
    dataTypeName: string; // Data type name (if applicable)
    /**
     * @generated from protobuf field: string file = 12
     */
    file: string; // Source file where error occurred
    /**
     * @generated from protobuf field: string line = 13
     */
    line: string; // Line number in source file
    /**
     * @generated from protobuf field: string routine = 14
     */
    routine: string; // Routine name where error occurred
}
/**
 * Prepared statement information
 *
 * @generated from protobuf message tusk.drift.instrumentation.postgresql.v1.PostgreSQLPreparedStatement
 */
export interface PostgreSQLPreparedStatement {
    /**
     * @generated from protobuf field: string statement_name = 1
     */
    statementName: string; // Name of prepared statement
    /**
     * @generated from protobuf field: string query_text = 2
     */
    queryText: string; // Original query text
    /**
     * @generated from protobuf field: repeated tusk.drift.instrumentation.postgresql.v1.PostgreSQLParameterType parameter_types = 3
     */
    parameterTypes: PostgreSQLParameterType[]; // Parameter type information
    /**
     * @generated from protobuf field: google.protobuf.Timestamp prepared_at = 4
     */
    preparedAt?: Timestamp; // When statement was prepared
    /**
     * @generated from protobuf field: int32 execution_count = 5
     */
    executionCount: number; // How many times executed
}
/**
 * Parameter type information for prepared statements
 *
 * @generated from protobuf message tusk.drift.instrumentation.postgresql.v1.PostgreSQLParameterType
 */
export interface PostgreSQLParameterType {
    /**
     * @generated from protobuf field: int32 position = 1
     */
    position: number; // Parameter position (1-based)
    /**
     * @generated from protobuf field: int32 data_type_id = 2
     */
    dataTypeId: number; // PostgreSQL data type OID
    /**
     * @generated from protobuf field: string data_type_name = 3
     */
    dataTypeName: string; // Human-readable type name
    /**
     * @generated from protobuf field: bool nullable = 4
     */
    nullable: boolean; // Whether parameter can be null
}
/**
 * Transaction context
 *
 * @generated from protobuf message tusk.drift.instrumentation.postgresql.v1.PostgreSQLTransaction
 */
export interface PostgreSQLTransaction {
    /**
     * @generated from protobuf field: string transaction_id = 1
     */
    transactionId: string; // Transaction identifier
    /**
     * @generated from protobuf field: tusk.drift.instrumentation.postgresql.v1.TransactionState state = 2
     */
    state: TransactionState; // Current transaction state
    /**
     * @generated from protobuf field: tusk.drift.instrumentation.postgresql.v1.IsolationLevel isolation_level = 3
     */
    isolationLevel: IsolationLevel; // Transaction isolation level
    /**
     * @generated from protobuf field: bool read_only = 4
     */
    readOnly: boolean; // Whether transaction is read-only
    /**
     * @generated from protobuf field: google.protobuf.Timestamp started_at = 5
     */
    startedAt?: Timestamp; // When transaction started
}
/**
 * Batch query support
 *
 * @generated from protobuf message tusk.drift.instrumentation.postgresql.v1.PostgreSQLBatch
 */
export interface PostgreSQLBatch {
    /**
     * @generated from protobuf field: repeated tusk.drift.instrumentation.postgresql.v1.PostgreSQLQuery queries = 1
     */
    queries: PostgreSQLQuery[]; // Queries in the batch
    /**
     * @generated from protobuf field: bool stop_on_error = 2
     */
    stopOnError: boolean; // Whether to stop on first error
    /**
     * @generated from protobuf field: bool return_results = 3
     */
    returnResults: boolean; // Whether to return individual results
}
/**
 * Batch result
 *
 * @generated from protobuf message tusk.drift.instrumentation.postgresql.v1.PostgreSQLBatchResult
 */
export interface PostgreSQLBatchResult {
    /**
     * @generated from protobuf field: repeated tusk.drift.instrumentation.postgresql.v1.PostgreSQLResult results = 1
     */
    results: PostgreSQLResult[]; // Results for each query
    /**
     * @generated from protobuf field: int32 successful_queries = 2
     */
    successfulQueries: number; // Number of successful queries
    /**
     * @generated from protobuf field: int32 failed_queries = 3
     */
    failedQueries: number; // Number of failed queries
    /**
     * @generated from protobuf field: optional tusk.drift.instrumentation.postgresql.v1.PostgreSQLError first_error = 4
     */
    firstError?: PostgreSQLError; // First error encountered (if any)
}
/**
 * Transaction state enumeration
 *
 * @generated from protobuf enum tusk.drift.instrumentation.postgresql.v1.TransactionState
 */
export enum TransactionState {
    /**
     * @generated from protobuf enum value: TRANSACTION_STATE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Not in a transaction
     *
     * @generated from protobuf enum value: TRANSACTION_STATE_IDLE = 1;
     */
    IDLE = 1,
    /**
     * Transaction active
     *
     * @generated from protobuf enum value: TRANSACTION_STATE_ACTIVE = 2;
     */
    ACTIVE = 2,
    /**
     * Idle in transaction
     *
     * @generated from protobuf enum value: TRANSACTION_STATE_IDLE_IN_TRANSACTION = 3;
     */
    IDLE_IN_TRANSACTION = 3,
    /**
     * Idle in failed transaction
     *
     * @generated from protobuf enum value: TRANSACTION_STATE_IDLE_IN_FAILED_TRANSACTION = 4;
     */
    IDLE_IN_FAILED_TRANSACTION = 4
}
/**
 * PostgreSQL isolation levels
 *
 * @generated from protobuf enum tusk.drift.instrumentation.postgresql.v1.IsolationLevel
 */
export enum IsolationLevel {
    /**
     * @generated from protobuf enum value: ISOLATION_LEVEL_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: ISOLATION_LEVEL_READ_UNCOMMITTED = 1;
     */
    READ_UNCOMMITTED = 1,
    /**
     * @generated from protobuf enum value: ISOLATION_LEVEL_READ_COMMITTED = 2;
     */
    READ_COMMITTED = 2,
    /**
     * @generated from protobuf enum value: ISOLATION_LEVEL_REPEATABLE_READ = 3;
     */
    REPEATABLE_READ = 3,
    /**
     * @generated from protobuf enum value: ISOLATION_LEVEL_SERIALIZABLE = 4;
     */
    SERIALIZABLE = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class PostgreSQLQuery$Type extends MessageType<PostgreSQLQuery> {
    constructor() {
        super("tusk.drift.instrumentation.postgresql.v1.PostgreSQLQuery", [
            { no: 1, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "values", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "client_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "connection", kind: "message", T: () => PostgreSQLConnection },
            { no: 5, name: "options", kind: "message", T: () => QueryOptions },
            { no: 6, name: "query_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "tags", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<PostgreSQLQuery>): PostgreSQLQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = "";
        message.values = [];
        message.clientType = "";
        message.queryId = "";
        message.tags = {};
        if (value !== undefined)
            reflectionMergePartial<PostgreSQLQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostgreSQLQuery): PostgreSQLQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.text = reader.string();
                    break;
                case /* repeated string values */ 2:
                    message.values.push(reader.string());
                    break;
                case /* string client_type */ 3:
                    message.clientType = reader.string();
                    break;
                case /* tusk.drift.instrumentation.postgresql.v1.PostgreSQLConnection connection */ 4:
                    message.connection = PostgreSQLConnection.internalBinaryRead(reader, reader.uint32(), options, message.connection);
                    break;
                case /* tusk.drift.instrumentation.postgresql.v1.QueryOptions options */ 5:
                    message.options = QueryOptions.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                case /* string query_id */ 6:
                    message.queryId = reader.string();
                    break;
                case /* map<string, string> tags */ 7:
                    this.binaryReadMap7(message.tags, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: PostgreSQLQuery["tags"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PostgreSQLQuery["tags"] | undefined, val: PostgreSQLQuery["tags"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for tusk.drift.instrumentation.postgresql.v1.PostgreSQLQuery.tags");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: PostgreSQLQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.text !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        /* repeated string values = 2; */
        for (let i = 0; i < message.values.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.values[i]);
        /* string client_type = 3; */
        if (message.clientType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.clientType);
        /* tusk.drift.instrumentation.postgresql.v1.PostgreSQLConnection connection = 4; */
        if (message.connection)
            PostgreSQLConnection.internalBinaryWrite(message.connection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* tusk.drift.instrumentation.postgresql.v1.QueryOptions options = 5; */
        if (message.options)
            QueryOptions.internalBinaryWrite(message.options, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string query_id = 6; */
        if (message.queryId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.queryId);
        /* map<string, string> tags = 7; */
        for (let k of globalThis.Object.keys(message.tags))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.tags[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tusk.drift.instrumentation.postgresql.v1.PostgreSQLQuery
 */
export const PostgreSQLQuery = new PostgreSQLQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostgreSQLConnection$Type extends MessageType<PostgreSQLConnection> {
    constructor() {
        super("tusk.drift.instrumentation.postgresql.v1.PostgreSQLConnection", [
            { no: 1, name: "database_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "host", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "application_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "connection_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "ssl_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "server_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PostgreSQLConnection>): PostgreSQLConnection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.databaseName = "";
        message.username = "";
        message.host = "";
        message.port = 0;
        message.applicationName = "";
        message.connectionId = "";
        message.sslEnabled = false;
        message.serverVersion = "";
        if (value !== undefined)
            reflectionMergePartial<PostgreSQLConnection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostgreSQLConnection): PostgreSQLConnection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string database_name */ 1:
                    message.databaseName = reader.string();
                    break;
                case /* string username */ 2:
                    message.username = reader.string();
                    break;
                case /* string host */ 3:
                    message.host = reader.string();
                    break;
                case /* int32 port */ 4:
                    message.port = reader.int32();
                    break;
                case /* string application_name */ 5:
                    message.applicationName = reader.string();
                    break;
                case /* string connection_id */ 6:
                    message.connectionId = reader.string();
                    break;
                case /* bool ssl_enabled */ 7:
                    message.sslEnabled = reader.bool();
                    break;
                case /* string server_version */ 8:
                    message.serverVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostgreSQLConnection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string database_name = 1; */
        if (message.databaseName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.databaseName);
        /* string username = 2; */
        if (message.username !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.username);
        /* string host = 3; */
        if (message.host !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.host);
        /* int32 port = 4; */
        if (message.port !== 0)
            writer.tag(4, WireType.Varint).int32(message.port);
        /* string application_name = 5; */
        if (message.applicationName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.applicationName);
        /* string connection_id = 6; */
        if (message.connectionId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.connectionId);
        /* bool ssl_enabled = 7; */
        if (message.sslEnabled !== false)
            writer.tag(7, WireType.Varint).bool(message.sslEnabled);
        /* string server_version = 8; */
        if (message.serverVersion !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.serverVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tusk.drift.instrumentation.postgresql.v1.PostgreSQLConnection
 */
export const PostgreSQLConnection = new PostgreSQLConnection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryOptions$Type extends MessageType<QueryOptions> {
    constructor() {
        super("tusk.drift.instrumentation.postgresql.v1.QueryOptions", [
            { no: 1, name: "statement_timeout", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "query_timeout", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "binary_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "cursor_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "fetch_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "read_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "custom_options", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<QueryOptions>): QueryOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statementTimeout = 0;
        message.queryTimeout = 0;
        message.binaryMode = false;
        message.cursorName = "";
        message.fetchSize = 0;
        message.readOnly = false;
        message.customOptions = {};
        if (value !== undefined)
            reflectionMergePartial<QueryOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryOptions): QueryOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 statement_timeout */ 1:
                    message.statementTimeout = reader.int32();
                    break;
                case /* int32 query_timeout */ 2:
                    message.queryTimeout = reader.int32();
                    break;
                case /* bool binary_mode */ 3:
                    message.binaryMode = reader.bool();
                    break;
                case /* string cursor_name */ 4:
                    message.cursorName = reader.string();
                    break;
                case /* int32 fetch_size */ 5:
                    message.fetchSize = reader.int32();
                    break;
                case /* bool read_only */ 6:
                    message.readOnly = reader.bool();
                    break;
                case /* map<string, string> custom_options */ 7:
                    this.binaryReadMap7(message.customOptions, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: QueryOptions["customOptions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof QueryOptions["customOptions"] | undefined, val: QueryOptions["customOptions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for tusk.drift.instrumentation.postgresql.v1.QueryOptions.custom_options");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: QueryOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 statement_timeout = 1; */
        if (message.statementTimeout !== 0)
            writer.tag(1, WireType.Varint).int32(message.statementTimeout);
        /* int32 query_timeout = 2; */
        if (message.queryTimeout !== 0)
            writer.tag(2, WireType.Varint).int32(message.queryTimeout);
        /* bool binary_mode = 3; */
        if (message.binaryMode !== false)
            writer.tag(3, WireType.Varint).bool(message.binaryMode);
        /* string cursor_name = 4; */
        if (message.cursorName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.cursorName);
        /* int32 fetch_size = 5; */
        if (message.fetchSize !== 0)
            writer.tag(5, WireType.Varint).int32(message.fetchSize);
        /* bool read_only = 6; */
        if (message.readOnly !== false)
            writer.tag(6, WireType.Varint).bool(message.readOnly);
        /* map<string, string> custom_options = 7; */
        for (let k of globalThis.Object.keys(message.customOptions))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.customOptions[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tusk.drift.instrumentation.postgresql.v1.QueryOptions
 */
export const QueryOptions = new QueryOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostgreSQLResult$Type extends MessageType<PostgreSQLResult> {
    constructor() {
        super("tusk.drift.instrumentation.postgresql.v1.PostgreSQLResult", [
            { no: 1, name: "command", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "row_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "oid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "rows", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Struct },
            { no: 5, name: "fields", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PostgreSQLField },
            { no: 6, name: "execution_info", kind: "message", T: () => QueryExecutionInfo },
            { no: 7, name: "error", kind: "message", T: () => PostgreSQLError }
        ]);
    }
    create(value?: PartialMessage<PostgreSQLResult>): PostgreSQLResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.command = "";
        message.rowCount = 0;
        message.rows = [];
        message.fields = [];
        if (value !== undefined)
            reflectionMergePartial<PostgreSQLResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostgreSQLResult): PostgreSQLResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string command */ 1:
                    message.command = reader.string();
                    break;
                case /* int32 row_count */ 2:
                    message.rowCount = reader.int32();
                    break;
                case /* optional int32 oid */ 3:
                    message.oid = reader.int32();
                    break;
                case /* repeated google.protobuf.Struct rows */ 4:
                    message.rows.push(Struct.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated tusk.drift.instrumentation.postgresql.v1.PostgreSQLField fields */ 5:
                    message.fields.push(PostgreSQLField.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* tusk.drift.instrumentation.postgresql.v1.QueryExecutionInfo execution_info */ 6:
                    message.executionInfo = QueryExecutionInfo.internalBinaryRead(reader, reader.uint32(), options, message.executionInfo);
                    break;
                case /* optional tusk.drift.instrumentation.postgresql.v1.PostgreSQLError error */ 7:
                    message.error = PostgreSQLError.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostgreSQLResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string command = 1; */
        if (message.command !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.command);
        /* int32 row_count = 2; */
        if (message.rowCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.rowCount);
        /* optional int32 oid = 3; */
        if (message.oid !== undefined)
            writer.tag(3, WireType.Varint).int32(message.oid);
        /* repeated google.protobuf.Struct rows = 4; */
        for (let i = 0; i < message.rows.length; i++)
            Struct.internalBinaryWrite(message.rows[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated tusk.drift.instrumentation.postgresql.v1.PostgreSQLField fields = 5; */
        for (let i = 0; i < message.fields.length; i++)
            PostgreSQLField.internalBinaryWrite(message.fields[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tusk.drift.instrumentation.postgresql.v1.QueryExecutionInfo execution_info = 6; */
        if (message.executionInfo)
            QueryExecutionInfo.internalBinaryWrite(message.executionInfo, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional tusk.drift.instrumentation.postgresql.v1.PostgreSQLError error = 7; */
        if (message.error)
            PostgreSQLError.internalBinaryWrite(message.error, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tusk.drift.instrumentation.postgresql.v1.PostgreSQLResult
 */
export const PostgreSQLResult = new PostgreSQLResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostgreSQLField$Type extends MessageType<PostgreSQLField> {
    constructor() {
        super("tusk.drift.instrumentation.postgresql.v1.PostgreSQLField", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "table_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "column_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "data_type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "data_type_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "data_type_modifier", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "format", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "data_type_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "nullable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "primary_key", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PostgreSQLField>): PostgreSQLField {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.tableId = 0;
        message.columnId = 0;
        message.dataTypeId = 0;
        message.dataTypeSize = 0;
        message.dataTypeModifier = 0;
        message.format = "";
        message.dataTypeName = "";
        message.nullable = false;
        message.primaryKey = false;
        if (value !== undefined)
            reflectionMergePartial<PostgreSQLField>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostgreSQLField): PostgreSQLField {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 table_id */ 2:
                    message.tableId = reader.int32();
                    break;
                case /* int32 column_id */ 3:
                    message.columnId = reader.int32();
                    break;
                case /* int32 data_type_id */ 4:
                    message.dataTypeId = reader.int32();
                    break;
                case /* int32 data_type_size */ 5:
                    message.dataTypeSize = reader.int32();
                    break;
                case /* int32 data_type_modifier */ 6:
                    message.dataTypeModifier = reader.int32();
                    break;
                case /* string format */ 7:
                    message.format = reader.string();
                    break;
                case /* string data_type_name */ 8:
                    message.dataTypeName = reader.string();
                    break;
                case /* bool nullable */ 9:
                    message.nullable = reader.bool();
                    break;
                case /* bool primary_key */ 10:
                    message.primaryKey = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostgreSQLField, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 table_id = 2; */
        if (message.tableId !== 0)
            writer.tag(2, WireType.Varint).int32(message.tableId);
        /* int32 column_id = 3; */
        if (message.columnId !== 0)
            writer.tag(3, WireType.Varint).int32(message.columnId);
        /* int32 data_type_id = 4; */
        if (message.dataTypeId !== 0)
            writer.tag(4, WireType.Varint).int32(message.dataTypeId);
        /* int32 data_type_size = 5; */
        if (message.dataTypeSize !== 0)
            writer.tag(5, WireType.Varint).int32(message.dataTypeSize);
        /* int32 data_type_modifier = 6; */
        if (message.dataTypeModifier !== 0)
            writer.tag(6, WireType.Varint).int32(message.dataTypeModifier);
        /* string format = 7; */
        if (message.format !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.format);
        /* string data_type_name = 8; */
        if (message.dataTypeName !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.dataTypeName);
        /* bool nullable = 9; */
        if (message.nullable !== false)
            writer.tag(9, WireType.Varint).bool(message.nullable);
        /* bool primary_key = 10; */
        if (message.primaryKey !== false)
            writer.tag(10, WireType.Varint).bool(message.primaryKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tusk.drift.instrumentation.postgresql.v1.PostgreSQLField
 */
export const PostgreSQLField = new PostgreSQLField$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryExecutionInfo$Type extends MessageType<QueryExecutionInfo> {
    constructor() {
        super("tusk.drift.instrumentation.postgresql.v1.QueryExecutionInfo", [
            { no: 1, name: "parse_time_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "plan_time_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "execute_time_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "total_time_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "rows_examined", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "rows_returned", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "bytes_sent", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "bytes_received", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "execution_plan", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "notices", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryExecutionInfo>): QueryExecutionInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.parseTimeMs = 0n;
        message.planTimeMs = 0n;
        message.executeTimeMs = 0n;
        message.totalTimeMs = 0n;
        message.rowsExamined = 0n;
        message.rowsReturned = 0n;
        message.bytesSent = 0n;
        message.bytesReceived = 0n;
        message.executionPlan = "";
        message.notices = [];
        if (value !== undefined)
            reflectionMergePartial<QueryExecutionInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryExecutionInfo): QueryExecutionInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 parse_time_ms */ 1:
                    message.parseTimeMs = reader.int64().toBigInt();
                    break;
                case /* int64 plan_time_ms */ 2:
                    message.planTimeMs = reader.int64().toBigInt();
                    break;
                case /* int64 execute_time_ms */ 3:
                    message.executeTimeMs = reader.int64().toBigInt();
                    break;
                case /* int64 total_time_ms */ 4:
                    message.totalTimeMs = reader.int64().toBigInt();
                    break;
                case /* int64 rows_examined */ 5:
                    message.rowsExamined = reader.int64().toBigInt();
                    break;
                case /* int64 rows_returned */ 6:
                    message.rowsReturned = reader.int64().toBigInt();
                    break;
                case /* int64 bytes_sent */ 7:
                    message.bytesSent = reader.int64().toBigInt();
                    break;
                case /* int64 bytes_received */ 8:
                    message.bytesReceived = reader.int64().toBigInt();
                    break;
                case /* string execution_plan */ 9:
                    message.executionPlan = reader.string();
                    break;
                case /* repeated string notices */ 10:
                    message.notices.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryExecutionInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 parse_time_ms = 1; */
        if (message.parseTimeMs !== 0n)
            writer.tag(1, WireType.Varint).int64(message.parseTimeMs);
        /* int64 plan_time_ms = 2; */
        if (message.planTimeMs !== 0n)
            writer.tag(2, WireType.Varint).int64(message.planTimeMs);
        /* int64 execute_time_ms = 3; */
        if (message.executeTimeMs !== 0n)
            writer.tag(3, WireType.Varint).int64(message.executeTimeMs);
        /* int64 total_time_ms = 4; */
        if (message.totalTimeMs !== 0n)
            writer.tag(4, WireType.Varint).int64(message.totalTimeMs);
        /* int64 rows_examined = 5; */
        if (message.rowsExamined !== 0n)
            writer.tag(5, WireType.Varint).int64(message.rowsExamined);
        /* int64 rows_returned = 6; */
        if (message.rowsReturned !== 0n)
            writer.tag(6, WireType.Varint).int64(message.rowsReturned);
        /* int64 bytes_sent = 7; */
        if (message.bytesSent !== 0n)
            writer.tag(7, WireType.Varint).int64(message.bytesSent);
        /* int64 bytes_received = 8; */
        if (message.bytesReceived !== 0n)
            writer.tag(8, WireType.Varint).int64(message.bytesReceived);
        /* string execution_plan = 9; */
        if (message.executionPlan !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.executionPlan);
        /* repeated string notices = 10; */
        for (let i = 0; i < message.notices.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.notices[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tusk.drift.instrumentation.postgresql.v1.QueryExecutionInfo
 */
export const QueryExecutionInfo = new QueryExecutionInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostgreSQLError$Type extends MessageType<PostgreSQLError> {
    constructor() {
        super("tusk.drift.instrumentation.postgresql.v1.PostgreSQLError", [
            { no: 1, name: "sql_state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "detail", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "hint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "position", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "where", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "schema_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "table_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "column_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "constraint_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "data_type_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "file", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "line", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "routine", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PostgreSQLError>): PostgreSQLError {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sqlState = "";
        message.message = "";
        message.detail = "";
        message.hint = "";
        message.position = "";
        message.where = "";
        message.schemaName = "";
        message.tableName = "";
        message.columnName = "";
        message.constraintName = "";
        message.dataTypeName = "";
        message.file = "";
        message.line = "";
        message.routine = "";
        if (value !== undefined)
            reflectionMergePartial<PostgreSQLError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostgreSQLError): PostgreSQLError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sql_state */ 1:
                    message.sqlState = reader.string();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* string detail */ 3:
                    message.detail = reader.string();
                    break;
                case /* string hint */ 4:
                    message.hint = reader.string();
                    break;
                case /* string position */ 5:
                    message.position = reader.string();
                    break;
                case /* string where */ 6:
                    message.where = reader.string();
                    break;
                case /* string schema_name */ 7:
                    message.schemaName = reader.string();
                    break;
                case /* string table_name */ 8:
                    message.tableName = reader.string();
                    break;
                case /* string column_name */ 9:
                    message.columnName = reader.string();
                    break;
                case /* string constraint_name */ 10:
                    message.constraintName = reader.string();
                    break;
                case /* string data_type_name */ 11:
                    message.dataTypeName = reader.string();
                    break;
                case /* string file */ 12:
                    message.file = reader.string();
                    break;
                case /* string line */ 13:
                    message.line = reader.string();
                    break;
                case /* string routine */ 14:
                    message.routine = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostgreSQLError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sql_state = 1; */
        if (message.sqlState !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sqlState);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* string detail = 3; */
        if (message.detail !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.detail);
        /* string hint = 4; */
        if (message.hint !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.hint);
        /* string position = 5; */
        if (message.position !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.position);
        /* string where = 6; */
        if (message.where !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.where);
        /* string schema_name = 7; */
        if (message.schemaName !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.schemaName);
        /* string table_name = 8; */
        if (message.tableName !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.tableName);
        /* string column_name = 9; */
        if (message.columnName !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.columnName);
        /* string constraint_name = 10; */
        if (message.constraintName !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.constraintName);
        /* string data_type_name = 11; */
        if (message.dataTypeName !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.dataTypeName);
        /* string file = 12; */
        if (message.file !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.file);
        /* string line = 13; */
        if (message.line !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.line);
        /* string routine = 14; */
        if (message.routine !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.routine);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tusk.drift.instrumentation.postgresql.v1.PostgreSQLError
 */
export const PostgreSQLError = new PostgreSQLError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostgreSQLPreparedStatement$Type extends MessageType<PostgreSQLPreparedStatement> {
    constructor() {
        super("tusk.drift.instrumentation.postgresql.v1.PostgreSQLPreparedStatement", [
            { no: 1, name: "statement_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "query_text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "parameter_types", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PostgreSQLParameterType },
            { no: 4, name: "prepared_at", kind: "message", T: () => Timestamp },
            { no: 5, name: "execution_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PostgreSQLPreparedStatement>): PostgreSQLPreparedStatement {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statementName = "";
        message.queryText = "";
        message.parameterTypes = [];
        message.executionCount = 0;
        if (value !== undefined)
            reflectionMergePartial<PostgreSQLPreparedStatement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostgreSQLPreparedStatement): PostgreSQLPreparedStatement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string statement_name */ 1:
                    message.statementName = reader.string();
                    break;
                case /* string query_text */ 2:
                    message.queryText = reader.string();
                    break;
                case /* repeated tusk.drift.instrumentation.postgresql.v1.PostgreSQLParameterType parameter_types */ 3:
                    message.parameterTypes.push(PostgreSQLParameterType.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Timestamp prepared_at */ 4:
                    message.preparedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.preparedAt);
                    break;
                case /* int32 execution_count */ 5:
                    message.executionCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostgreSQLPreparedStatement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string statement_name = 1; */
        if (message.statementName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.statementName);
        /* string query_text = 2; */
        if (message.queryText !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.queryText);
        /* repeated tusk.drift.instrumentation.postgresql.v1.PostgreSQLParameterType parameter_types = 3; */
        for (let i = 0; i < message.parameterTypes.length; i++)
            PostgreSQLParameterType.internalBinaryWrite(message.parameterTypes[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp prepared_at = 4; */
        if (message.preparedAt)
            Timestamp.internalBinaryWrite(message.preparedAt, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int32 execution_count = 5; */
        if (message.executionCount !== 0)
            writer.tag(5, WireType.Varint).int32(message.executionCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tusk.drift.instrumentation.postgresql.v1.PostgreSQLPreparedStatement
 */
export const PostgreSQLPreparedStatement = new PostgreSQLPreparedStatement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostgreSQLParameterType$Type extends MessageType<PostgreSQLParameterType> {
    constructor() {
        super("tusk.drift.instrumentation.postgresql.v1.PostgreSQLParameterType", [
            { no: 1, name: "position", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "data_type_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "data_type_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "nullable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PostgreSQLParameterType>): PostgreSQLParameterType {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.position = 0;
        message.dataTypeId = 0;
        message.dataTypeName = "";
        message.nullable = false;
        if (value !== undefined)
            reflectionMergePartial<PostgreSQLParameterType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostgreSQLParameterType): PostgreSQLParameterType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 position */ 1:
                    message.position = reader.int32();
                    break;
                case /* int32 data_type_id */ 2:
                    message.dataTypeId = reader.int32();
                    break;
                case /* string data_type_name */ 3:
                    message.dataTypeName = reader.string();
                    break;
                case /* bool nullable */ 4:
                    message.nullable = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostgreSQLParameterType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 position = 1; */
        if (message.position !== 0)
            writer.tag(1, WireType.Varint).int32(message.position);
        /* int32 data_type_id = 2; */
        if (message.dataTypeId !== 0)
            writer.tag(2, WireType.Varint).int32(message.dataTypeId);
        /* string data_type_name = 3; */
        if (message.dataTypeName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.dataTypeName);
        /* bool nullable = 4; */
        if (message.nullable !== false)
            writer.tag(4, WireType.Varint).bool(message.nullable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tusk.drift.instrumentation.postgresql.v1.PostgreSQLParameterType
 */
export const PostgreSQLParameterType = new PostgreSQLParameterType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostgreSQLTransaction$Type extends MessageType<PostgreSQLTransaction> {
    constructor() {
        super("tusk.drift.instrumentation.postgresql.v1.PostgreSQLTransaction", [
            { no: 1, name: "transaction_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "state", kind: "enum", T: () => ["tusk.drift.instrumentation.postgresql.v1.TransactionState", TransactionState, "TRANSACTION_STATE_"] },
            { no: 3, name: "isolation_level", kind: "enum", T: () => ["tusk.drift.instrumentation.postgresql.v1.IsolationLevel", IsolationLevel, "ISOLATION_LEVEL_"] },
            { no: 4, name: "read_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "started_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<PostgreSQLTransaction>): PostgreSQLTransaction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactionId = "";
        message.state = 0;
        message.isolationLevel = 0;
        message.readOnly = false;
        if (value !== undefined)
            reflectionMergePartial<PostgreSQLTransaction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostgreSQLTransaction): PostgreSQLTransaction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string transaction_id */ 1:
                    message.transactionId = reader.string();
                    break;
                case /* tusk.drift.instrumentation.postgresql.v1.TransactionState state */ 2:
                    message.state = reader.int32();
                    break;
                case /* tusk.drift.instrumentation.postgresql.v1.IsolationLevel isolation_level */ 3:
                    message.isolationLevel = reader.int32();
                    break;
                case /* bool read_only */ 4:
                    message.readOnly = reader.bool();
                    break;
                case /* google.protobuf.Timestamp started_at */ 5:
                    message.startedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostgreSQLTransaction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string transaction_id = 1; */
        if (message.transactionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.transactionId);
        /* tusk.drift.instrumentation.postgresql.v1.TransactionState state = 2; */
        if (message.state !== 0)
            writer.tag(2, WireType.Varint).int32(message.state);
        /* tusk.drift.instrumentation.postgresql.v1.IsolationLevel isolation_level = 3; */
        if (message.isolationLevel !== 0)
            writer.tag(3, WireType.Varint).int32(message.isolationLevel);
        /* bool read_only = 4; */
        if (message.readOnly !== false)
            writer.tag(4, WireType.Varint).bool(message.readOnly);
        /* google.protobuf.Timestamp started_at = 5; */
        if (message.startedAt)
            Timestamp.internalBinaryWrite(message.startedAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tusk.drift.instrumentation.postgresql.v1.PostgreSQLTransaction
 */
export const PostgreSQLTransaction = new PostgreSQLTransaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostgreSQLBatch$Type extends MessageType<PostgreSQLBatch> {
    constructor() {
        super("tusk.drift.instrumentation.postgresql.v1.PostgreSQLBatch", [
            { no: 1, name: "queries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PostgreSQLQuery },
            { no: 2, name: "stop_on_error", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "return_results", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PostgreSQLBatch>): PostgreSQLBatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.queries = [];
        message.stopOnError = false;
        message.returnResults = false;
        if (value !== undefined)
            reflectionMergePartial<PostgreSQLBatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostgreSQLBatch): PostgreSQLBatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tusk.drift.instrumentation.postgresql.v1.PostgreSQLQuery queries */ 1:
                    message.queries.push(PostgreSQLQuery.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool stop_on_error */ 2:
                    message.stopOnError = reader.bool();
                    break;
                case /* bool return_results */ 3:
                    message.returnResults = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostgreSQLBatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tusk.drift.instrumentation.postgresql.v1.PostgreSQLQuery queries = 1; */
        for (let i = 0; i < message.queries.length; i++)
            PostgreSQLQuery.internalBinaryWrite(message.queries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool stop_on_error = 2; */
        if (message.stopOnError !== false)
            writer.tag(2, WireType.Varint).bool(message.stopOnError);
        /* bool return_results = 3; */
        if (message.returnResults !== false)
            writer.tag(3, WireType.Varint).bool(message.returnResults);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tusk.drift.instrumentation.postgresql.v1.PostgreSQLBatch
 */
export const PostgreSQLBatch = new PostgreSQLBatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostgreSQLBatchResult$Type extends MessageType<PostgreSQLBatchResult> {
    constructor() {
        super("tusk.drift.instrumentation.postgresql.v1.PostgreSQLBatchResult", [
            { no: 1, name: "results", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PostgreSQLResult },
            { no: 2, name: "successful_queries", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "failed_queries", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "first_error", kind: "message", T: () => PostgreSQLError }
        ]);
    }
    create(value?: PartialMessage<PostgreSQLBatchResult>): PostgreSQLBatchResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        message.successfulQueries = 0;
        message.failedQueries = 0;
        if (value !== undefined)
            reflectionMergePartial<PostgreSQLBatchResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostgreSQLBatchResult): PostgreSQLBatchResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tusk.drift.instrumentation.postgresql.v1.PostgreSQLResult results */ 1:
                    message.results.push(PostgreSQLResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 successful_queries */ 2:
                    message.successfulQueries = reader.int32();
                    break;
                case /* int32 failed_queries */ 3:
                    message.failedQueries = reader.int32();
                    break;
                case /* optional tusk.drift.instrumentation.postgresql.v1.PostgreSQLError first_error */ 4:
                    message.firstError = PostgreSQLError.internalBinaryRead(reader, reader.uint32(), options, message.firstError);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostgreSQLBatchResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tusk.drift.instrumentation.postgresql.v1.PostgreSQLResult results = 1; */
        for (let i = 0; i < message.results.length; i++)
            PostgreSQLResult.internalBinaryWrite(message.results[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 successful_queries = 2; */
        if (message.successfulQueries !== 0)
            writer.tag(2, WireType.Varint).int32(message.successfulQueries);
        /* int32 failed_queries = 3; */
        if (message.failedQueries !== 0)
            writer.tag(3, WireType.Varint).int32(message.failedQueries);
        /* optional tusk.drift.instrumentation.postgresql.v1.PostgreSQLError first_error = 4; */
        if (message.firstError)
            PostgreSQLError.internalBinaryWrite(message.firstError, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tusk.drift.instrumentation.postgresql.v1.PostgreSQLBatchResult
 */
export const PostgreSQLBatchResult = new PostgreSQLBatchResult$Type();
