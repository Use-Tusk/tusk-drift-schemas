# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: core/json_schema.proto, core/span.proto, core/communication.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, List, Optional

import betterproto
import grpclib

from .google import protobuf


class JsonSchemaType(betterproto.Enum):
    """
    JSON schema type enumeration Language-agnostic type classification for JSON
    values
    """

    JSON_SCHEMA_TYPE_UNSPECIFIED = 0
    JSON_SCHEMA_TYPE_NUMBER = 1
    JSON_SCHEMA_TYPE_STRING = 2
    JSON_SCHEMA_TYPE_BOOLEAN = 3
    JSON_SCHEMA_TYPE_NULL = 4
    JSON_SCHEMA_TYPE_UNDEFINED = 5
    JSON_SCHEMA_TYPE_OBJECT = 6
    JSON_SCHEMA_TYPE_ORDERED_LIST = 7
    JSON_SCHEMA_TYPE_UNORDERED_LIST = 8
    JSON_SCHEMA_TYPE_FUNCTION = 9


class EncodingType(betterproto.Enum):
    """Encoding type for data serialization"""

    ENCODING_TYPE_UNSPECIFIED = 0
    ENCODING_TYPE_BASE64 = 1


class DecodedType(betterproto.Enum):
    """
    Decoded content type classification Describes the semantic type of decoded
    content
    """

    DECODED_TYPE_UNSPECIFIED = 0
    DECODED_TYPE_JSON = 1
    DECODED_TYPE_HTML = 2
    DECODED_TYPE_CSS = 3
    DECODED_TYPE_JAVASCRIPT = 4
    DECODED_TYPE_XML = 5
    DECODED_TYPE_YAML = 6
    DECODED_TYPE_MARKDOWN = 7
    DECODED_TYPE_CSV = 8
    DECODED_TYPE_SQL = 9
    DECODED_TYPE_GRAPHQL = 10
    DECODED_TYPE_PLAIN_TEXT = 11
    DECODED_TYPE_FORM_DATA = 12
    DECODED_TYPE_MULTIPART_FORM = 13
    DECODED_TYPE_PDF = 14
    DECODED_TYPE_AUDIO = 15
    DECODED_TYPE_VIDEO = 16
    DECODED_TYPE_GZIP = 17
    DECODED_TYPE_BINARY = 18
    DECODED_TYPE_JPEG = 19
    DECODED_TYPE_PNG = 20
    DECODED_TYPE_GIF = 21
    DECODED_TYPE_WEBP = 22
    DECODED_TYPE_SVG = 23
    DECODED_TYPE_ZIP = 24


class PackageType(betterproto.Enum):
    """Package type classification enum Langauge agnostic"""

    PACKAGE_TYPE_UNSPECIFIED = 0
    PACKAGE_TYPE_HTTP = 1
    PACKAGE_TYPE_GRAPHQL = 2
    PACKAGE_TYPE_GRPC = 3
    PACKAGE_TYPE_PG = 4
    PACKAGE_TYPE_MYSQL = 5
    PACKAGE_TYPE_MONGODB = 6
    PACKAGE_TYPE_REDIS = 7
    PACKAGE_TYPE_KAFKA = 8
    PACKAGE_TYPE_RABBITMQ = 9
    PACKAGE_TYPE_FIRESTORE = 10
    PACKAGE_TYPE_PRISMA = 11


class SpanKind(betterproto.Enum):
    """OpenTelemetry-compatible span kinds"""

    SPAN_KIND_UNSPECIFIED = 0
    SPAN_KIND_INTERNAL = 1
    SPAN_KIND_SERVER = 2
    SPAN_KIND_CLIENT = 3
    SPAN_KIND_PRODUCER = 4
    SPAN_KIND_CONSUMER = 5


class StatusCode(betterproto.Enum):
    STATUS_CODE_UNSPECIFIED = 0
    STATUS_CODE_OK = 1
    STATUS_CODE_ERROR = 2


class MessageType(betterproto.Enum):
    MESSAGE_TYPE_UNSPECIFIED = 0
    MESSAGE_TYPE_SDK_CONNECT = 1
    MESSAGE_TYPE_MOCK_REQUEST = 2
    MESSAGE_TYPE_INBOUND_SPAN = 3
    MESSAGE_TYPE_ALERT = 4
    MESSAGE_TYPE_ENV_VAR_REQUEST = 5


@dataclass
class JsonSchema(betterproto.Message):
    """
    Recursive JSON schema message Describes the structure and metadata of JSON
    data
    """

    # The type of this schema node
    type: "JsonSchemaType" = betterproto.enum_field(1)
    # For OBJECT types: map of property names to their schemas
    properties: Dict[str, "JsonSchema"] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    # For ORDERED_LIST/UNORDERED_LIST types: schema of list items
    items: "JsonSchema" = betterproto.message_field(3, group="_items")
    # Optional encoding information (e.g., BASE64)
    encoding: "EncodingType" = betterproto.enum_field(4, group="_encoding")
    # Optional decoded content type (e.g., JSON, HTML)
    decoded_type: "DecodedType" = betterproto.enum_field(5, group="_decoded_type")
    # Match importance for test matching (0.0 to 1.0) 0.0 = lowest importance,
    # 1.0 = highest importance
    match_importance: float = betterproto.double_field(6, group="_match_importance")


@dataclass
class Span(betterproto.Message):
    """Universal span structure that works for all instrumentation types"""

    # Core span identity
    trace_id: str = betterproto.string_field(1)
    span_id: str = betterproto.string_field(2)
    parent_span_id: str = betterproto.string_field(3)
    # Visual name
    name: str = betterproto.string_field(4)
    # Instrumentation identity
    package_name: str = betterproto.string_field(5)
    instrumentation_name: str = betterproto.string_field(6)
    submodule_name: str = betterproto.string_field(7)
    # Package type classification
    package_type: "PackageType" = betterproto.enum_field(8)
    # Input/output data
    input_value: protobuf.Struct = betterproto.message_field(9)
    output_value: protobuf.Struct = betterproto.message_field(10)
    input_schema: "JsonSchema" = betterproto.message_field(11)
    output_schema: "JsonSchema" = betterproto.message_field(12)
    # Hash-based matching and validation
    input_schema_hash: str = betterproto.string_field(13)
    output_schema_hash: str = betterproto.string_field(14)
    input_value_hash: str = betterproto.string_field(15)
    output_value_hash: str = betterproto.string_field(16)
    # Span metadata
    kind: "SpanKind" = betterproto.enum_field(17)
    status: "SpanStatus" = betterproto.message_field(18)
    is_pre_app_start: bool = betterproto.bool_field(19)
    # Timing information
    timestamp: datetime = betterproto.message_field(20)
    duration: timedelta = betterproto.message_field(21)
    # Span relationships and state
    is_root_span: bool = betterproto.bool_field(22)
    metadata: protobuf.Struct = betterproto.message_field(23)


@dataclass
class SpanStatus(betterproto.Message):
    """Span completion status"""

    code: "StatusCode" = betterproto.enum_field(1)
    message: str = betterproto.string_field(2)


@dataclass
class SpanEvent(betterproto.Message):
    """Span events (logs) - optional"""

    name: str = betterproto.string_field(1)
    timestamp: datetime = betterproto.message_field(2)
    attributes: Dict[str, protobuf.Value] = betterproto.map_field(
        3, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )


@dataclass
class SpanLink(betterproto.Message):
    """Span links - optional"""

    trace_id: str = betterproto.string_field(1)
    span_id: str = betterproto.string_field(2)
    attributes: Dict[str, protobuf.Value] = betterproto.map_field(
        3, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )


@dataclass
class Trace(betterproto.Message):
    """Trace collection"""

    trace_id: str = betterproto.string_field(1)
    spans: List["Span"] = betterproto.message_field(2)
    started_at: datetime = betterproto.message_field(3)
    completed_at: datetime = betterproto.message_field(4)
    metadata: Dict[str, str] = betterproto.map_field(
        5, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class ConnectRequest(betterproto.Message):
    """SDK connection handshake"""

    service_id: str = betterproto.string_field(1)
    sdk_version: str = betterproto.string_field(2)
    min_cli_version: str = betterproto.string_field(3)
    metadata: protobuf.Struct = betterproto.message_field(4)


@dataclass
class ConnectResponse(betterproto.Message):
    success: bool = betterproto.bool_field(1)
    error: str = betterproto.string_field(2)


@dataclass
class GetMockRequest(betterproto.Message):
    request_id: str = betterproto.string_field(1)
    test_id: str = betterproto.string_field(2)
    outbound_span: "Span" = betterproto.message_field(3)
    stack_trace: str = betterproto.string_field(4)
    operation: str = betterproto.string_field(5)
    tags: Dict[str, str] = betterproto.map_field(
        6, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    requested_at: datetime = betterproto.message_field(7)


@dataclass
class GetMockResponse(betterproto.Message):
    request_id: str = betterproto.string_field(1)
    found: bool = betterproto.bool_field(2)
    # Opaque response data - CLI returns as-is from stored spans
    response_data: protobuf.Struct = betterproto.message_field(3)
    metadata: protobuf.Struct = betterproto.message_field(4)
    # Error information
    error: str = betterproto.string_field(5)
    error_code: str = betterproto.string_field(6)
    # Mock metadata
    matched_span_id: str = betterproto.string_field(7)
    matched_at: datetime = betterproto.message_field(8)


@dataclass
class SDKMessage(betterproto.Message):
    """Message types for the Unix socket protocol"""

    type: "MessageType" = betterproto.enum_field(1)
    request_id: str = betterproto.string_field(2)
    connect_request: "ConnectRequest" = betterproto.message_field(3, group="payload")
    get_mock_request: "GetMockRequest" = betterproto.message_field(4, group="payload")
    send_inbound_span_for_replay_request: "SendInboundSpanForReplayRequest" = (
        betterproto.message_field(5, group="payload")
    )
    send_alert_request: "SendAlertRequest" = betterproto.message_field(
        6, group="payload"
    )
    env_var_request: "EnvVarRequest" = betterproto.message_field(7, group="payload")


@dataclass
class CLIMessage(betterproto.Message):
    type: "MessageType" = betterproto.enum_field(1)
    request_id: str = betterproto.string_field(2)
    connect_response: "ConnectResponse" = betterproto.message_field(3, group="payload")
    get_mock_response: "GetMockResponse" = betterproto.message_field(4, group="payload")
    send_inbound_span_for_replay_response: "SendInboundSpanForReplayResponse" = (
        betterproto.message_field(5, group="payload")
    )
    env_var_response: "EnvVarResponse" = betterproto.message_field(6, group="payload")


@dataclass
class SendInboundSpanForReplayRequest(betterproto.Message):
    span: "Span" = betterproto.message_field(1)


@dataclass
class SendInboundSpanForReplayResponse(betterproto.Message):
    success: bool = betterproto.bool_field(1)


@dataclass
class SendAlertRequest(betterproto.Message):
    version_mismatch: "InstrumentationVersionMismatchAlert" = betterproto.message_field(
        1, group="alert"
    )
    unpatched_dependency: "UnpatchedDependencyAlert" = betterproto.message_field(
        2, group="alert"
    )


@dataclass
class InstrumentationVersionMismatchAlert(betterproto.Message):
    module_name: str = betterproto.string_field(1)
    requested_version: str = betterproto.string_field(2)
    supported_versions: List[str] = betterproto.string_field(3)
    sdk_version: str = betterproto.string_field(4)


@dataclass
class UnpatchedDependencyAlert(betterproto.Message):
    stack_trace: str = betterproto.string_field(1)
    trace_test_server_span_id: str = betterproto.string_field(2)
    sdk_version: str = betterproto.string_field(3)


@dataclass
class EnvVarRequest(betterproto.Message):
    trace_test_server_span_id: str = betterproto.string_field(1)


@dataclass
class EnvVarResponse(betterproto.Message):
    env_vars: Dict[str, str] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


class MockServiceStub(betterproto.ServiceStub):
    """
    Generic protocol between CLI and SDK - completely instrumentation-agnostic
    """

    async def connect(
        self,
        *,
        service_id: str = "",
        sdk_version: str = "",
        min_cli_version: str = "",
        metadata: Optional[protobuf.Struct] = None,
    ) -> ConnectResponse:
        request = ConnectRequest()
        request.service_id = service_id
        request.sdk_version = sdk_version
        request.min_cli_version = min_cli_version
        if metadata is not None:
            request.metadata = metadata

        return await self._unary_unary(
            "/tusk.drift.core.v1.MockService/Connect",
            request,
            ConnectResponse,
        )

    async def get_mock(
        self,
        *,
        request_id: str = "",
        test_id: str = "",
        outbound_span: Optional["Span"] = None,
        stack_trace: str = "",
        operation: str = "",
        tags: Optional[Dict[str, str]] = None,
        requested_at: Optional[datetime] = None,
    ) -> GetMockResponse:
        request = GetMockRequest()
        request.request_id = request_id
        request.test_id = test_id
        if outbound_span is not None:
            request.outbound_span = outbound_span
        request.stack_trace = stack_trace
        request.operation = operation
        request.tags = tags
        if requested_at is not None:
            request.requested_at = requested_at

        return await self._unary_unary(
            "/tusk.drift.core.v1.MockService/GetMock",
            request,
            GetMockResponse,
        )

    async def send_inbound_span_for_replay(
        self, *, span: Optional["Span"] = None
    ) -> SendInboundSpanForReplayResponse:
        request = SendInboundSpanForReplayRequest()
        if span is not None:
            request.span = span

        return await self._unary_unary(
            "/tusk.drift.core.v1.MockService/SendInboundSpanForReplay",
            request,
            SendInboundSpanForReplayResponse,
        )
