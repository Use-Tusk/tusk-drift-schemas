# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: backend/client_service.proto, backend/common.proto, backend/span_export_service.proto, backend/test_run_service.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List

import betterproto
import grpclib

from .tusk.drift.core import v1


class UserType(betterproto.Enum):
    USER_TYPE_UNSPECIFIED = 0
    USER_TYPE_USER = 1
    USER_TYPE_API_KEY = 2


class CodeHostingResourceType(betterproto.Enum):
    CODE_HOSTING_RESOURCE_TYPE_UNSPECIFIED = 0
    CODE_HOSTING_RESOURCE_TYPE_GITHUB = 1
    CODE_HOSTING_RESOURCE_TYPE_GITLAB = 2


class ServiceType(betterproto.Enum):
    SERVICE_TYPE_UNSPECIFIED = 0
    SERVICE_TYPE_NODE = 1


class CreateObservableServiceResponseErrorCode(betterproto.Enum):
    CREATE_OBSERVABLE_SERVICE_RESPONSE_ERROR_CODE_UNSPECIFIED = 0
    CREATE_OBSERVABLE_SERVICE_RESPONSE_ERROR_CODE_INTERNAL = 1
    CREATE_OBSERVABLE_SERVICE_RESPONSE_ERROR_CODE_NOT_AUTHORIZED = 2
    CREATE_OBSERVABLE_SERVICE_RESPONSE_ERROR_CODE_NO_CODE_HOSTING_RESOURCE = 3
    CREATE_OBSERVABLE_SERVICE_RESPONSE_ERROR_CODE_NO_REPO_FOUND = 4


class VerifyRepoAccessResponseErrorCode(betterproto.Enum):
    VERIFY_REPO_ACCESS_RESPONSE_ERROR_CODE_UNSPECIFIED = 0
    VERIFY_REPO_ACCESS_RESPONSE_ERROR_CODE_INTERNAL = 1
    VERIFY_REPO_ACCESS_RESPONSE_ERROR_CODE_NOT_AUTHORIZED = 2
    VERIFY_REPO_ACCESS_RESPONSE_ERROR_CODE_NO_CODE_HOSTING_RESOURCE = 3
    VERIFY_REPO_ACCESS_RESPONSE_ERROR_CODE_REPO_NOT_FOUND = 4


class CreateApiKeyResponseErrorCode(betterproto.Enum):
    CREATE_API_KEY_RESPONSE_ERROR_CODE_UNSPECIFIED = 0
    CREATE_API_KEY_RESPONSE_ERROR_CODE_INTERNAL = 1
    CREATE_API_KEY_RESPONSE_ERROR_CODE_NOT_AUTHORIZED = 2


class MatchScope(betterproto.Enum):
    MATCH_SCOPE_UNSPECIFIED = 0
    MATCH_SCOPE_TRACE = 1
    MATCH_SCOPE_GLOBAL = 2


class MatchType(betterproto.Enum):
    MATCH_TYPE_UNSPECIFIED = 0
    MATCH_TYPE_INPUT_VALUE_HASH = 1
    MATCH_TYPE_INPUT_VALUE_HASH_REDUCED_SCHEMA = 2
    MATCH_TYPE_INPUT_SCHEMA_HASH = 3
    MATCH_TYPE_INPUT_SCHEMA_HASH_REDUCED_SCHEMA = 4
    MATCH_TYPE_FUZZY = 5
    MATCH_TYPE_FALLBACK = 6


class TraceTestFailureReason(betterproto.Enum):
    TRACE_TEST_FAILURE_REASON_UNSPECIFIED = 0
    TRACE_TEST_FAILURE_REASON_MOCK_NOT_FOUND = 1
    TRACE_TEST_FAILURE_REASON_RESPONSE_MISMATCH = 2
    TRACE_TEST_FAILURE_REASON_NO_RESPONSE = 3


class DriftRunCIStatus(betterproto.Enum):
    DRIFT_RUN_CI_STATUS_UNSPECIFIED = 0
    DRIFT_RUN_CI_STATUS_RUNNING = 1
    DRIFT_RUN_CI_STATUS_SUCCESS = 2
    DRIFT_RUN_CI_STATUS_FAILURE = 3


@dataclass
class GetAuthInfoRequest(betterproto.Message):
    client_id: str = betterproto.string_field(1, group="_client_id")


@dataclass
class UserAuthInfo(betterproto.Message):
    id: str = betterproto.string_field(1)
    type: "UserType" = betterproto.enum_field(2)
    name: str = betterproto.string_field(3)
    email: str = betterproto.string_field(4, group="_email")
    code_hosting_username: str = betterproto.string_field(
        5, group="_code_hosting_username"
    )


@dataclass
class AuthInfoClient(betterproto.Message):
    id: str = betterproto.string_field(1)
    name: str = betterproto.string_field(2, group="_name")
    domain: str = betterproto.string_field(3, group="_domain")
    feature_flags: List[str] = betterproto.string_field(4)
    code_hosting_resources: List["CodeHostingResource"] = betterproto.message_field(5)


@dataclass
class CodeHostingResource(betterproto.Message):
    id: int = betterproto.int64_field(1)
    type: "CodeHostingResourceType" = betterproto.enum_field(2)
    external_id: str = betterproto.string_field(3)


@dataclass
class GetAuthInfoResponse(betterproto.Message):
    user: "UserAuthInfo" = betterproto.message_field(1)
    clients: List["AuthInfoClient"] = betterproto.message_field(2)


@dataclass
class CreateObservableServiceRequest(betterproto.Message):
    repo_owner_name: str = betterproto.string_field(1)
    repo_name: str = betterproto.string_field(2)
    service_type: "ServiceType" = betterproto.enum_field(3)
    app_dir: str = betterproto.string_field(4, group="_app_dir")


@dataclass
class CreateObservableServiceResponseSuccess(betterproto.Message):
    observable_service_id: str = betterproto.string_field(1)


@dataclass
class CreateObservableServiceResponseError(betterproto.Message):
    code: "CreateObservableServiceResponseErrorCode" = betterproto.enum_field(1)
    message: str = betterproto.string_field(2)


@dataclass
class CreateObservableServiceResponse(betterproto.Message):
    success: "CreateObservableServiceResponseSuccess" = betterproto.message_field(
        1, group="response"
    )
    error: "CreateObservableServiceResponseError" = betterproto.message_field(
        2, group="response"
    )


@dataclass
class VerifyRepoAccessRequest(betterproto.Message):
    repo_owner_name: str = betterproto.string_field(1)
    repo_name: str = betterproto.string_field(2)


@dataclass
class VerifyRepoAccessResponseSuccess(betterproto.Message):
    repo_id: int = betterproto.int64_field(1)


@dataclass
class VerifyRepoAccessResponseError(betterproto.Message):
    code: "VerifyRepoAccessResponseErrorCode" = betterproto.enum_field(1)
    message: str = betterproto.string_field(2)


@dataclass
class VerifyRepoAccessResponse(betterproto.Message):
    success: "VerifyRepoAccessResponseSuccess" = betterproto.message_field(
        1, group="response"
    )
    error: "VerifyRepoAccessResponseError" = betterproto.message_field(
        2, group="response"
    )


@dataclass
class CreateApiKeyRequest(betterproto.Message):
    name: str = betterproto.string_field(1)


@dataclass
class CreateApiKeyResponse(betterproto.Message):
    success: "CreateApiKeyResponseSuccess" = betterproto.message_field(
        1, group="response"
    )
    error: "CreateApiKeyResponseError" = betterproto.message_field(2, group="response")


@dataclass
class CreateApiKeyResponseSuccess(betterproto.Message):
    api_key_id: str = betterproto.string_field(1)
    api_key: str = betterproto.string_field(2)


@dataclass
class CreateApiKeyResponseError(betterproto.Message):
    code: "CreateApiKeyResponseErrorCode" = betterproto.enum_field(1)
    message: str = betterproto.string_field(2)


@dataclass
class ExportSpansRequest(betterproto.Message):
    observable_service_id: str = betterproto.string_field(1)
    environment: str = betterproto.string_field(2)
    sdk_version: str = betterproto.string_field(3)
    sdk_instance_id: str = betterproto.string_field(4)
    spans: List[v1.Span] = betterproto.message_field(5)


@dataclass
class ExportSpansResponse(betterproto.Message):
    success: bool = betterproto.bool_field(1)
    # TODO: Add field to indicate number of spans saved?
    message: str = betterproto.string_field(2)


@dataclass
class GetGlobalSpansRequest(betterproto.Message):
    observable_service_id: str = betterproto.string_field(1)
    # Optional since first page will have no cursor
    pagination_cursor: str = betterproto.string_field(2, group="_pagination_cursor")
    # Server should provide next cursor based on this page size
    page_size: int = betterproto.int32_field(3)


@dataclass
class GetGlobalSpansResponseSuccess(betterproto.Message):
    spans: List[v1.Span] = betterproto.message_field(1)
    next_cursor: str = betterproto.string_field(2, group="_next_cursor")
    total_count: int = betterproto.int32_field(3)


@dataclass
class GetGlobalSpansResponseError(betterproto.Message):
    code: str = betterproto.string_field(1)
    message: str = betterproto.string_field(2)


@dataclass
class GetGlobalSpansResponse(betterproto.Message):
    success: "GetGlobalSpansResponseSuccess" = betterproto.message_field(
        1, group="response"
    )
    error: "GetGlobalSpansResponseError" = betterproto.message_field(
        2, group="response"
    )


@dataclass
class GetPreAppStartSpansRequest(betterproto.Message):
    observable_service_id: str = betterproto.string_field(1)
    pagination_cursor: str = betterproto.string_field(2, group="_pagination_cursor")
    page_size: int = betterproto.int32_field(3)


@dataclass
class GetPreAppStartSpansResponseSuccess(betterproto.Message):
    spans: List[v1.Span] = betterproto.message_field(1)
    next_cursor: str = betterproto.string_field(2, group="_next_cursor")
    total_count: int = betterproto.int32_field(3)


@dataclass
class GetPreAppStartSpansResponseError(betterproto.Message):
    code: str = betterproto.string_field(1)
    message: str = betterproto.string_field(2)


@dataclass
class GetPreAppStartSpansResponse(betterproto.Message):
    success: "GetPreAppStartSpansResponseSuccess" = betterproto.message_field(
        1, group="response"
    )
    error: "GetPreAppStartSpansResponseError" = betterproto.message_field(
        2, group="response"
    )


@dataclass
class CreateDriftRunRequest(betterproto.Message):
    observable_service_id: str = betterproto.string_field(1)
    cli_version: str = betterproto.string_field(2)
    commit_sha: str = betterproto.string_field(3)
    pr_number: str = betterproto.string_field(4)
    branch_name: str = betterproto.string_field(5)
    external_check_run_id: str = betterproto.string_field(6)


@dataclass
class CreateDriftRunResponseSuccess(betterproto.Message):
    drift_run_id: str = betterproto.string_field(1)


@dataclass
class CreateDriftRunResponseError(betterproto.Message):
    # Machine-readable error code, could be an enum
    code: str = betterproto.string_field(1)
    # Human-readable error message
    message: str = betterproto.string_field(2)


@dataclass
class CreateDriftRunResponse(betterproto.Message):
    success: "CreateDriftRunResponseSuccess" = betterproto.message_field(
        1, group="response"
    )
    error: "CreateDriftRunResponseError" = betterproto.message_field(
        2, group="response"
    )


@dataclass
class GetDriftRunTraceTestsRequest(betterproto.Message):
    drift_run_id: str = betterproto.string_field(1)
    pagination_cursor: str = betterproto.string_field(2, group="_pagination_cursor")
    # Server should provide next cursor based on this page size
    page_size: int = betterproto.int32_field(3)


@dataclass
class TraceTest(betterproto.Message):
    id: str = betterproto.string_field(1)
    trace_id: str = betterproto.string_field(2)
    server_span_recording_id: str = betterproto.string_field(3)
    spans: List[v1.Span] = betterproto.message_field(4)


@dataclass
class GetDriftRunTraceTestsResponseSuccess(betterproto.Message):
    trace_tests: List["TraceTest"] = betterproto.message_field(1)
    next_cursor: str = betterproto.string_field(2, group="_next_cursor")
    total_count: int = betterproto.int32_field(3)


@dataclass
class GetDriftRunTraceTestsResponseError(betterproto.Message):
    # Machine-readable error code, could be an enum
    code: str = betterproto.string_field(1)
    # Human-readable error message
    message: str = betterproto.string_field(2)


@dataclass
class GetDriftRunTraceTestsResponse(betterproto.Message):
    success: "GetDriftRunTraceTestsResponseSuccess" = betterproto.message_field(
        1, group="response"
    )
    error: "GetDriftRunTraceTestsResponseError" = betterproto.message_field(
        2, group="response"
    )


@dataclass
class GetTraceTestRequest(betterproto.Message):
    observable_service_id: str = betterproto.string_field(1)
    trace_test_id: str = betterproto.string_field(2)


@dataclass
class GetTraceTestResponse(betterproto.Message):
    success: "GetTraceTestResponseSuccess" = betterproto.message_field(
        1, group="response"
    )
    error: "GetTraceTestResponseError" = betterproto.message_field(2, group="response")


@dataclass
class GetTraceTestResponseSuccess(betterproto.Message):
    trace_test: "TraceTest" = betterproto.message_field(1)


@dataclass
class GetTraceTestResponseError(betterproto.Message):
    code: str = betterproto.string_field(1)
    message: str = betterproto.string_field(2)


@dataclass
class GetAllTraceTestsRequest(betterproto.Message):
    observable_service_id: str = betterproto.string_field(1)
    pagination_cursor: str = betterproto.string_field(2, group="_pagination_cursor")
    # Server should provide next cursor based on this page size
    page_size: int = betterproto.int32_field(3)


@dataclass
class GetAllTraceTestsResponseSuccess(betterproto.Message):
    trace_tests: List["TraceTest"] = betterproto.message_field(1)
    next_cursor: str = betterproto.string_field(2, group="_next_cursor")
    total_count: int = betterproto.int32_field(3)


@dataclass
class GetAllTraceTestsResponseError(betterproto.Message):
    code: str = betterproto.string_field(1)
    message: str = betterproto.string_field(2)


@dataclass
class GetAllTraceTestsResponse(betterproto.Message):
    success: "GetAllTraceTestsResponseSuccess" = betterproto.message_field(
        1, group="response"
    )
    error: "GetAllTraceTestsResponseError" = betterproto.message_field(
        2, group="response"
    )


@dataclass
class Deviation(betterproto.Message):
    field: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)


@dataclass
class MatchLevel(betterproto.Message):
    match_type: "MatchType" = betterproto.enum_field(1)
    match_scope: "MatchScope" = betterproto.enum_field(2)
    match_description: str = betterproto.string_field(3)
    # Similarity scoring fields (populated when multiple matches exist)
    similarity_score: float = betterproto.float_field(4, group="_similarity_score")
    top_candidates: List["SimilarityCandidate"] = betterproto.message_field(5)


@dataclass
class SimilarityCandidate(betterproto.Message):
    span_id: str = betterproto.string_field(1)
    score: float = betterproto.float_field(2)


@dataclass
class TraceTestSpanResult(betterproto.Message):
    # Create a separate table in backend for span_result_recording, but very
    # similar schema to
    replay_span: v1.Span = betterproto.message_field(1)
    # All nullable since we want to allow for no matching span_recordings This
    # should be the DB id of the matched span_recording
    matched_span_recording_id: str = betterproto.string_field(
        2, group="_matched_span_recording_id"
    )
    match_level: "MatchLevel" = betterproto.message_field(3, group="_match_level")
    stack_trace: str = betterproto.string_field(4, group="_stack_trace")
    deviations: List["Deviation"] = betterproto.message_field(5)


@dataclass
class TraceTestResult(betterproto.Message):
    trace_test_id: str = betterproto.string_field(1)
    test_success: bool = betterproto.bool_field(2)
    test_failure_reason: "TraceTestFailureReason" = betterproto.enum_field(
        3, group="_test_failure_reason"
    )
    test_failure_message: str = betterproto.string_field(
        4, group="_test_failure_message"
    )
    replay_trace_id: str = betterproto.string_field(5, group="_replay_trace_id")
    replay_server_span_id: str = betterproto.string_field(
        6, group="_replay_server_span_id"
    )
    span_results: List["TraceTestSpanResult"] = betterproto.message_field(7)


@dataclass
class UploadTraceTestResultsRequest(betterproto.Message):
    drift_run_id: str = betterproto.string_field(1)
    cli_version: str = betterproto.string_field(2)
    sdk_version: str = betterproto.string_field(3)
    trace_test_results: List["TraceTestResult"] = betterproto.message_field(4)


@dataclass
class UploadTraceTestResultsResponseSuccess(betterproto.Message):
    message: str = betterproto.string_field(1)


@dataclass
class UploadTraceTestResultsResponseError(betterproto.Message):
    code: str = betterproto.string_field(1)
    message: str = betterproto.string_field(2)


@dataclass
class UploadTraceTestResultsResponse(betterproto.Message):
    success: "UploadTraceTestResultsResponseSuccess" = betterproto.message_field(
        1, group="response"
    )
    error: "UploadTraceTestResultsResponseError" = betterproto.message_field(
        2, group="response"
    )


@dataclass
class UpdateDriftRunCIStatusRequest(betterproto.Message):
    drift_run_id: str = betterproto.string_field(1)
    ci_status: "DriftRunCIStatus" = betterproto.enum_field(2)
    ci_status_message: str = betterproto.string_field(3, group="_ci_status_message")


@dataclass
class UpdateDriftRunCIStatusResponseSuccess(betterproto.Message):
    message: str = betterproto.string_field(1)


@dataclass
class UpdateDriftRunCIStatusResponseError(betterproto.Message):
    code: str = betterproto.string_field(1)
    message: str = betterproto.string_field(2)


@dataclass
class UpdateDriftRunCIStatusResponse(betterproto.Message):
    success: "UpdateDriftRunCIStatusResponseSuccess" = betterproto.message_field(
        1, group="response"
    )
    error: "UpdateDriftRunCIStatusResponseError" = betterproto.message_field(
        2, group="response"
    )


class ClientServiceStub(betterproto.ServiceStub):
    async def get_auth_info(self, *, client_id: str = "") -> GetAuthInfoResponse:
        request = GetAuthInfoRequest()
        request.client_id = client_id

        return await self._unary_unary(
            "/tusk.drift.backend.v1.ClientService/GetAuthInfo",
            request,
            GetAuthInfoResponse,
        )

    async def create_observable_service(
        self,
        *,
        repo_owner_name: str = "",
        repo_name: str = "",
        service_type: "ServiceType" = 0,
        app_dir: str = "",
    ) -> CreateObservableServiceResponse:
        request = CreateObservableServiceRequest()
        request.repo_owner_name = repo_owner_name
        request.repo_name = repo_name
        request.service_type = service_type
        request.app_dir = app_dir

        return await self._unary_unary(
            "/tusk.drift.backend.v1.ClientService/CreateObservableService",
            request,
            CreateObservableServiceResponse,
        )

    async def verify_repo_access(
        self, *, repo_owner_name: str = "", repo_name: str = ""
    ) -> VerifyRepoAccessResponse:
        request = VerifyRepoAccessRequest()
        request.repo_owner_name = repo_owner_name
        request.repo_name = repo_name

        return await self._unary_unary(
            "/tusk.drift.backend.v1.ClientService/VerifyRepoAccess",
            request,
            VerifyRepoAccessResponse,
        )

    async def create_api_key(self, *, name: str = "") -> CreateApiKeyResponse:
        request = CreateApiKeyRequest()
        request.name = name

        return await self._unary_unary(
            "/tusk.drift.backend.v1.ClientService/CreateApiKey",
            request,
            CreateApiKeyResponse,
        )


class SpanExportServiceStub(betterproto.ServiceStub):
    async def export_spans(
        self,
        *,
        observable_service_id: str = "",
        environment: str = "",
        sdk_version: str = "",
        sdk_instance_id: str = "",
        spans: List[v1.Span] = [],
    ) -> ExportSpansResponse:
        request = ExportSpansRequest()
        request.observable_service_id = observable_service_id
        request.environment = environment
        request.sdk_version = sdk_version
        request.sdk_instance_id = sdk_instance_id
        if spans is not None:
            request.spans = spans

        return await self._unary_unary(
            "/tusk.drift.backend.v1.SpanExportService/ExportSpans",
            request,
            ExportSpansResponse,
        )


class TestRunServiceStub(betterproto.ServiceStub):
    async def get_global_spans(
        self,
        *,
        observable_service_id: str = "",
        pagination_cursor: str = "",
        page_size: int = 0,
    ) -> GetGlobalSpansResponse:
        """
        Get global spans - spans that can be used across all tests e.g.
        outbound span to a jwks endpoint that may not be present in all traces
        we're replaying
        """

        request = GetGlobalSpansRequest()
        request.observable_service_id = observable_service_id
        request.pagination_cursor = pagination_cursor
        request.page_size = page_size

        return await self._unary_unary(
            "/tusk.drift.backend.v1.TestRunService/GetGlobalSpans",
            request,
            GetGlobalSpansResponse,
        )

    async def get_pre_app_start_spans(
        self,
        *,
        observable_service_id: str = "",
        pagination_cursor: str = "",
        page_size: int = 0,
    ) -> GetPreAppStartSpansResponse:
        """Get pre-app start spans - used to mock pre-app start spans"""

        request = GetPreAppStartSpansRequest()
        request.observable_service_id = observable_service_id
        request.pagination_cursor = pagination_cursor
        request.page_size = page_size

        return await self._unary_unary(
            "/tusk.drift.backend.v1.TestRunService/GetPreAppStartSpans",
            request,
            GetPreAppStartSpansResponse,
        )

    async def create_drift_run(
        self,
        *,
        observable_service_id: str = "",
        cli_version: str = "",
        commit_sha: str = "",
        pr_number: str = "",
        branch_name: str = "",
        external_check_run_id: str = "",
    ) -> CreateDriftRunResponse:
        """Create drift run in BE, also upserts commit and PR info"""

        request = CreateDriftRunRequest()
        request.observable_service_id = observable_service_id
        request.cli_version = cli_version
        request.commit_sha = commit_sha
        request.pr_number = pr_number
        request.branch_name = branch_name
        request.external_check_run_id = external_check_run_id

        return await self._unary_unary(
            "/tusk.drift.backend.v1.TestRunService/CreateDriftRun",
            request,
            CreateDriftRunResponse,
        )

    async def get_drift_run_trace_tests(
        self, *, drift_run_id: str = "", pagination_cursor: str = "", page_size: int = 0
    ) -> GetDriftRunTraceTestsResponse:
        """Get all trace tests for a drift run"""

        request = GetDriftRunTraceTestsRequest()
        request.drift_run_id = drift_run_id
        request.pagination_cursor = pagination_cursor
        request.page_size = page_size

        return await self._unary_unary(
            "/tusk.drift.backend.v1.TestRunService/GetDriftRunTraceTests",
            request,
            GetDriftRunTraceTestsResponse,
        )

    async def get_all_trace_tests(
        self,
        *,
        observable_service_id: str = "",
        pagination_cursor: str = "",
        page_size: int = 0,
    ) -> GetAllTraceTestsResponse:
        """Get all trace tests in test suite"""

        request = GetAllTraceTestsRequest()
        request.observable_service_id = observable_service_id
        request.pagination_cursor = pagination_cursor
        request.page_size = page_size

        return await self._unary_unary(
            "/tusk.drift.backend.v1.TestRunService/GetAllTraceTests",
            request,
            GetAllTraceTestsResponse,
        )

    async def get_trace_test(
        self, *, observable_service_id: str = "", trace_test_id: str = ""
    ) -> GetTraceTestResponse:
        """Get a single trace test"""

        request = GetTraceTestRequest()
        request.observable_service_id = observable_service_id
        request.trace_test_id = trace_test_id

        return await self._unary_unary(
            "/tusk.drift.backend.v1.TestRunService/GetTraceTest",
            request,
            GetTraceTestResponse,
        )

    async def upload_trace_test_results(
        self,
        *,
        drift_run_id: str = "",
        cli_version: str = "",
        sdk_version: str = "",
        trace_test_results: List["TraceTestResult"] = [],
    ) -> UploadTraceTestResultsResponse:
        """Upload trace test results to BE"""

        request = UploadTraceTestResultsRequest()
        request.drift_run_id = drift_run_id
        request.cli_version = cli_version
        request.sdk_version = sdk_version
        if trace_test_results is not None:
            request.trace_test_results = trace_test_results

        return await self._unary_unary(
            "/tusk.drift.backend.v1.TestRunService/UploadTraceTestResults",
            request,
            UploadTraceTestResultsResponse,
        )

    async def update_drift_run_c_i_status(
        self,
        *,
        drift_run_id: str = "",
        ci_status: "DriftRunCIStatus" = 0,
        ci_status_message: str = "",
    ) -> UpdateDriftRunCIStatusResponse:
        """
        Allows CLI to indicate to backend that it's done running trace tests
        This can also allow CLI to send a heartbeat to indicate it's still
        running
        """

        request = UpdateDriftRunCIStatusRequest()
        request.drift_run_id = drift_run_id
        request.ci_status = ci_status
        request.ci_status_message = ci_status_message

        return await self._unary_unary(
            "/tusk.drift.backend.v1.TestRunService/UpdateDriftRunCIStatus",
            request,
            UpdateDriftRunCIStatusResponse,
        )
